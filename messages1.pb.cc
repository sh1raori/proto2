// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages1.proto

#include "messages1.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR VideoMediaType::VideoMediaType(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.width_)*/0u
  , /*decltype(_impl_.height_)*/0u
  , /*decltype(_impl_.fps_num_)*/0u
  , /*decltype(_impl_.fps_den_)*/0u
  , /*decltype(_impl_.aspect_num_)*/0u
  , /*decltype(_impl_.aspect_den_)*/0u
  , /*decltype(_impl_.pix_fmt_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VideoMediaTypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoMediaTypeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoMediaTypeDefaultTypeInternal() {}
  union {
    VideoMediaType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoMediaTypeDefaultTypeInternal _VideoMediaType_default_instance_;
PROTOBUF_CONSTEXPR SubtitleMediaType_Pair::SubtitleMediaType_Pair(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubtitleMediaType_PairDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubtitleMediaType_PairDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubtitleMediaType_PairDefaultTypeInternal() {}
  union {
    SubtitleMediaType_Pair _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubtitleMediaType_PairDefaultTypeInternal _SubtitleMediaType_Pair_default_instance_;
PROTOBUF_CONSTEXPR SubtitleMediaType::SubtitleMediaType(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.metadata_)*/{}
  , /*decltype(_impl_.header_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.aspect_num_)*/0u
  , /*decltype(_impl_.aspect_den_)*/0u
  , /*decltype(_impl_.width_)*/0u
  , /*decltype(_impl_.height_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubtitleMediaTypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubtitleMediaTypeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubtitleMediaTypeDefaultTypeInternal() {}
  union {
    SubtitleMediaType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubtitleMediaTypeDefaultTypeInternal _SubtitleMediaType_default_instance_;
PROTOBUF_CONSTEXPR DataMediaType_Pair::DataMediaType_Pair(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DataMediaType_PairDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataMediaType_PairDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataMediaType_PairDefaultTypeInternal() {}
  union {
    DataMediaType_Pair _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataMediaType_PairDefaultTypeInternal _DataMediaType_Pair_default_instance_;
PROTOBUF_CONSTEXPR DataMediaType::DataMediaType(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.info_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DataMediaTypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataMediaTypeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataMediaTypeDefaultTypeInternal() {}
  union {
    DataMediaType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataMediaTypeDefaultTypeInternal _DataMediaType_default_instance_;
PROTOBUF_CONSTEXPR AudioMediaType::AudioMediaType(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.layout_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.freq_)*/0u
  , /*decltype(_impl_.nchan_)*/0u
  , /*decltype(_impl_.ssize_)*/0u
  , /*decltype(_impl_.sample_fmt_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AudioMediaTypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioMediaTypeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioMediaTypeDefaultTypeInternal() {}
  union {
    AudioMediaType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioMediaTypeDefaultTypeInternal _AudioMediaType_default_instance_;
PROTOBUF_CONSTEXPR Stream_Pair::Stream_Pair(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Stream_PairDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Stream_PairDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Stream_PairDefaultTypeInternal() {}
  union {
    Stream_Pair _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Stream_PairDefaultTypeInternal _Stream_Pair_default_instance_;
PROTOBUF_CONSTEXPR Stream::Stream(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.metadata_)*/{}
  , /*decltype(_impl_.codec_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.extradata_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.channel_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.videomt_)*/nullptr
  , /*decltype(_impl_.audiomt_)*/nullptr
  , /*decltype(_impl_.subtitlemt_)*/nullptr
  , /*decltype(_impl_.datamt_)*/nullptr
  , /*decltype(_impl_.avparams_)*/nullptr
  , /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.bitrate_)*/0u
  , /*decltype(_impl_.tb_num_)*/0u
  , /*decltype(_impl_.tb_den_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamDefaultTypeInternal() {}
  union {
    Stream _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamDefaultTypeInternal _Stream_default_instance_;
PROTOBUF_CONSTEXPR CodecParameters::CodecParameters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.extradata_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.codec_type_)*/0u
  , /*decltype(_impl_.codec_id_)*/0u
  , /*decltype(_impl_.codec_tag_)*/0u
  , /*decltype(_impl_.format_)*/0u
  , /*decltype(_impl_.bit_rate_)*/uint64_t{0u}
  , /*decltype(_impl_.bits_per_coded_sample_)*/0u
  , /*decltype(_impl_.bits_per_raw_sample_)*/0u
  , /*decltype(_impl_.profile_)*/0u
  , /*decltype(_impl_.level_)*/0u
  , /*decltype(_impl_.width_)*/0u
  , /*decltype(_impl_.height_)*/0u
  , /*decltype(_impl_.sample_aspect_ratio_num_)*/0
  , /*decltype(_impl_.sample_aspect_ratio_den_)*/0
  , /*decltype(_impl_.field_order_)*/0u
  , /*decltype(_impl_.color_range_)*/0u
  , /*decltype(_impl_.color_primaries_)*/0u
  , /*decltype(_impl_.color_trc_)*/0u
  , /*decltype(_impl_.color_space_)*/0u
  , /*decltype(_impl_.chroma_location_)*/0u
  , /*decltype(_impl_.channel_layout_)*/uint64_t{0u}
  , /*decltype(_impl_.video_delay_)*/0u
  , /*decltype(_impl_.channels_)*/0u
  , /*decltype(_impl_.sample_rate_)*/0u
  , /*decltype(_impl_.block_align_)*/0u
  , /*decltype(_impl_.frame_size_)*/0u
  , /*decltype(_impl_.initial_padding_)*/0u
  , /*decltype(_impl_.trailing_padding_)*/0u
  , /*decltype(_impl_.seek_preroll_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CodecParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CodecParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CodecParametersDefaultTypeInternal() {}
  union {
    CodecParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CodecParametersDefaultTypeInternal _CodecParameters_default_instance_;
PROTOBUF_CONSTEXPR MediaPacket::MediaPacket(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dts_)*/uint64_t{0u}
  , /*decltype(_impl_.stream_id_)*/0u
  , /*decltype(_impl_.pts_offset_)*/0u
  , /*decltype(_impl_.frametype_)*/0
  , /*decltype(_impl_.duration_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MediaPacketDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MediaPacketDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MediaPacketDefaultTypeInternal() {}
  union {
    MediaPacket _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MediaPacketDefaultTypeInternal _MediaPacket_default_instance_;
PROTOBUF_CONSTEXPR Start::Start(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.channel_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.start_ts_)*/uint64_t{0u}
  , /*decltype(_impl_.tb_num_)*/0u
  , /*decltype(_impl_.tb_den_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StartDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StartDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StartDefaultTypeInternal() {}
  union {
    Start _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StartDefaultTypeInternal _Start_default_instance_;
PROTOBUF_CONSTEXPR Stop::Stop(
    ::_pbi::ConstantInitialized) {}
struct StopDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StopDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StopDefaultTypeInternal() {}
  union {
    Stop _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StopDefaultTypeInternal _Stop_default_instance_;
PROTOBUF_CONSTEXPR GopSlice::GopSlice(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.packets_)*/{}
  , /*decltype(_impl_.ts_num_)*/int64_t{0}
  , /*decltype(_impl_.ts_den_)*/int64_t{0}
  , /*decltype(_impl_.duration_num_)*/int64_t{0}
  , /*decltype(_impl_.duration_den_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GopSliceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GopSliceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GopSliceDefaultTypeInternal() {}
  union {
    GopSlice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GopSliceDefaultTypeInternal _GopSlice_default_instance_;
PROTOBUF_CONSTEXPR Msg::Msg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stop_)*/nullptr
  , /*decltype(_impl_.start_)*/nullptr
  , /*decltype(_impl_.stream_)*/nullptr
  , /*decltype(_impl_.mediapacket_)*/nullptr
  , /*decltype(_impl_.gopslice_)*/nullptr
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MsgDefaultTypeInternal() {}
  union {
    Msg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MsgDefaultTypeInternal _Msg_default_instance_;
static ::_pb::Metadata file_level_metadata_messages1_2eproto[14];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_messages1_2eproto[5];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_messages1_2eproto = nullptr;

const uint32_t TableStruct_messages1_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::VideoMediaType, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::VideoMediaType, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::VideoMediaType, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::VideoMediaType, _impl_.fps_num_),
  PROTOBUF_FIELD_OFFSET(::VideoMediaType, _impl_.fps_den_),
  PROTOBUF_FIELD_OFFSET(::VideoMediaType, _impl_.aspect_num_),
  PROTOBUF_FIELD_OFFSET(::VideoMediaType, _impl_.aspect_den_),
  PROTOBUF_FIELD_OFFSET(::VideoMediaType, _impl_.pix_fmt_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SubtitleMediaType_Pair, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SubtitleMediaType_Pair, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::SubtitleMediaType_Pair, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SubtitleMediaType, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SubtitleMediaType, _impl_.aspect_num_),
  PROTOBUF_FIELD_OFFSET(::SubtitleMediaType, _impl_.aspect_den_),
  PROTOBUF_FIELD_OFFSET(::SubtitleMediaType, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::SubtitleMediaType, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::SubtitleMediaType, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::SubtitleMediaType, _impl_.height_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::DataMediaType_Pair, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::DataMediaType_Pair, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::DataMediaType_Pair, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::DataMediaType, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::DataMediaType, _impl_.info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AudioMediaType, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AudioMediaType, _impl_.freq_),
  PROTOBUF_FIELD_OFFSET(::AudioMediaType, _impl_.nchan_),
  PROTOBUF_FIELD_OFFSET(::AudioMediaType, _impl_.ssize_),
  PROTOBUF_FIELD_OFFSET(::AudioMediaType, _impl_.sample_fmt_),
  PROTOBUF_FIELD_OFFSET(::AudioMediaType, _impl_.layout_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Stream_Pair, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Stream_Pair, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::Stream_Pair, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Stream, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Stream, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::Stream, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::Stream, _impl_.codec_),
  PROTOBUF_FIELD_OFFSET(::Stream, _impl_.bitrate_),
  PROTOBUF_FIELD_OFFSET(::Stream, _impl_.tb_num_),
  PROTOBUF_FIELD_OFFSET(::Stream, _impl_.tb_den_),
  PROTOBUF_FIELD_OFFSET(::Stream, _impl_.extradata_),
  PROTOBUF_FIELD_OFFSET(::Stream, _impl_.videomt_),
  PROTOBUF_FIELD_OFFSET(::Stream, _impl_.audiomt_),
  PROTOBUF_FIELD_OFFSET(::Stream, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::Stream, _impl_.channel_),
  PROTOBUF_FIELD_OFFSET(::Stream, _impl_.subtitlemt_),
  PROTOBUF_FIELD_OFFSET(::Stream, _impl_.datamt_),
  PROTOBUF_FIELD_OFFSET(::Stream, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::Stream, _impl_.avparams_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.codec_type_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.codec_id_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.codec_tag_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.extradata_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.format_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.bit_rate_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.bits_per_coded_sample_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.bits_per_raw_sample_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.profile_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.level_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.sample_aspect_ratio_num_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.sample_aspect_ratio_den_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.field_order_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.color_range_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.color_primaries_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.color_trc_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.color_space_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.chroma_location_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.video_delay_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.channel_layout_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.channels_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.sample_rate_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.block_align_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.frame_size_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.initial_padding_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.trailing_padding_),
  PROTOBUF_FIELD_OFFSET(::CodecParameters, _impl_.seek_preroll_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::MediaPacket, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::MediaPacket, _impl_.stream_id_),
  PROTOBUF_FIELD_OFFSET(::MediaPacket, _impl_.dts_),
  PROTOBUF_FIELD_OFFSET(::MediaPacket, _impl_.pts_offset_),
  PROTOBUF_FIELD_OFFSET(::MediaPacket, _impl_.frametype_),
  PROTOBUF_FIELD_OFFSET(::MediaPacket, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::MediaPacket, _impl_.duration_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Start, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Start, _impl_.start_ts_),
  PROTOBUF_FIELD_OFFSET(::Start, _impl_.tb_num_),
  PROTOBUF_FIELD_OFFSET(::Start, _impl_.tb_den_),
  PROTOBUF_FIELD_OFFSET(::Start, _impl_.channel_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Stop, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::GopSlice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::GopSlice, _impl_.ts_num_),
  PROTOBUF_FIELD_OFFSET(::GopSlice, _impl_.ts_den_),
  PROTOBUF_FIELD_OFFSET(::GopSlice, _impl_.duration_num_),
  PROTOBUF_FIELD_OFFSET(::GopSlice, _impl_.duration_den_),
  PROTOBUF_FIELD_OFFSET(::GopSlice, _impl_.packets_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Msg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Msg, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::Msg, _impl_.stop_),
  PROTOBUF_FIELD_OFFSET(::Msg, _impl_.start_),
  PROTOBUF_FIELD_OFFSET(::Msg, _impl_.stream_),
  PROTOBUF_FIELD_OFFSET(::Msg, _impl_.mediapacket_),
  PROTOBUF_FIELD_OFFSET(::Msg, _impl_.gopslice_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::VideoMediaType)},
  { 13, -1, -1, sizeof(::SubtitleMediaType_Pair)},
  { 21, -1, -1, sizeof(::SubtitleMediaType)},
  { 33, -1, -1, sizeof(::DataMediaType_Pair)},
  { 41, -1, -1, sizeof(::DataMediaType)},
  { 48, -1, -1, sizeof(::AudioMediaType)},
  { 59, -1, -1, sizeof(::Stream_Pair)},
  { 67, -1, -1, sizeof(::Stream)},
  { 88, -1, -1, sizeof(::CodecParameters)},
  { 123, -1, -1, sizeof(::MediaPacket)},
  { 135, -1, -1, sizeof(::Start)},
  { 145, -1, -1, sizeof(::Stop)},
  { 151, -1, -1, sizeof(::GopSlice)},
  { 162, -1, -1, sizeof(::Msg)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_VideoMediaType_default_instance_._instance,
  &::_SubtitleMediaType_Pair_default_instance_._instance,
  &::_SubtitleMediaType_default_instance_._instance,
  &::_DataMediaType_Pair_default_instance_._instance,
  &::_DataMediaType_default_instance_._instance,
  &::_AudioMediaType_default_instance_._instance,
  &::_Stream_Pair_default_instance_._instance,
  &::_Stream_default_instance_._instance,
  &::_CodecParameters_default_instance_._instance,
  &::_MediaPacket_default_instance_._instance,
  &::_Start_default_instance_._instance,
  &::_Stop_default_instance_._instance,
  &::_GopSlice_default_instance_._instance,
  &::_Msg_default_instance_._instance,
};

const char descriptor_table_protodef_messages1_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\017messages1.proto\"\223\001\n\016VideoMediaType\022\r\n\005"
  "width\030\004 \001(\r\022\016\n\006height\030\005 \001(\r\022\017\n\007fps_num\030\006"
  " \001(\r\022\017\n\007fps_den\030\007 \001(\r\022\022\n\naspect_num\030\010 \001("
  "\r\022\022\n\naspect_den\030\t \001(\r\022\030\n\007pix_fmt\030\n \001(\0162\007"
  ".PixFmt\"\271\001\n\021SubtitleMediaType\022\022\n\naspect_"
  "num\030\001 \001(\r\022\022\n\naspect_den\030\002 \001(\r\022)\n\010metadat"
  "a\030\003 \003(\0132\027.SubtitleMediaType.Pair\022\016\n\006head"
  "er\030\004 \001(\014\022\r\n\005width\030\005 \001(\r\022\016\n\006height\030\006 \001(\r\032"
  "\"\n\004Pair\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t\"V\n\rD"
  "ataMediaType\022!\n\004info\030\001 \003(\0132\023.DataMediaTy"
  "pe.Pair\032\"\n\004Pair\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 "
  "\001(\t\"\345\001\n\016AudioMediaType\022\014\n\004freq\030\004 \001(\r\022\r\n\005"
  "nchan\030\005 \001(\r\022\r\n\005ssize\030\006 \001(\r\022-\n\nsample_fmt"
  "\030\007 \001(\0162\031.AudioMediaType.SampleFmt\022\016\n\006lay"
  "out\030\010 \001(\t\"h\n\tSampleFmt\022\007\n\003S16\020\000\022\006\n\002U8\020\001\022"
  "\007\n\003S32\020\002\022\007\n\003FLT\020\003\022\007\n\003DBL\020\004\022\007\n\003U8P\020\005\022\010\n\004S"
  "16P\020\006\022\010\n\004S32P\020\007\022\010\n\004FLTP\020\010\022\010\n\004DBLP\020\t\"\314\003\n\006"
  "Stream\022\n\n\002id\030\001 \001(\r\022\032\n\004type\030\002 \001(\0162\014.Strea"
  "m.Type\022\r\n\005codec\030\003 \001(\t\022\017\n\007bitrate\030\004 \001(\r\022\016"
  "\n\006tb_num\030\005 \001(\r\022\016\n\006tb_den\030\006 \001(\r\022\021\n\textrad"
  "ata\030\007 \001(\014\022 \n\007videomt\030\010 \001(\0132\017.VideoMediaT"
  "ype\022 \n\007audiomt\030\t \001(\0132\017.AudioMediaType\022\014\n"
  "\004name\030\n \001(\t\022\017\n\007channel\030\013 \001(\t\022&\n\nsubtitle"
  "mt\030\014 \001(\0132\022.SubtitleMediaType\022\036\n\006datamt\030\r"
  " \001(\0132\016.DataMediaType\022\036\n\010metadata\030\016 \003(\0132\014"
  ".Stream.Pair\022\"\n\010avparams\030\017 \001(\0132\020.CodecPa"
  "rameters\032\"\n\004Pair\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002"
  " \001(\t\"4\n\004Type\022\t\n\005VIDEO\020\000\022\t\n\005AUDIO\020\001\022\014\n\010SU"
  "BTITLE\020\002\022\010\n\004DATA\020\003\"\206\005\n\017CodecParameters\022\022"
  "\n\ncodec_type\030\001 \001(\r\022\020\n\010codec_id\030\002 \001(\r\022\021\n\t"
  "codec_tag\030\003 \001(\r\022\021\n\textradata\030\004 \001(\014\022\016\n\006fo"
  "rmat\030\005 \001(\r\022\020\n\010bit_rate\030\006 \001(\004\022\035\n\025bits_per"
  "_coded_sample\030\007 \001(\r\022\033\n\023bits_per_raw_samp"
  "le\030\010 \001(\r\022\017\n\007profile\030\t \001(\r\022\r\n\005level\030\n \001(\r"
  "\022\r\n\005width\030\013 \001(\r\022\016\n\006height\030\014 \001(\r\022\037\n\027sampl"
  "e_aspect_ratio_num\030\r \001(\005\022\037\n\027sample_aspec"
  "t_ratio_den\030\016 \001(\005\022\023\n\013field_order\030\017 \001(\r\022\023"
  "\n\013color_range\030\020 \001(\r\022\027\n\017color_primaries\030\021"
  " \001(\r\022\021\n\tcolor_trc\030\022 \001(\r\022\023\n\013color_space\030\023"
  " \001(\r\022\027\n\017chroma_location\030\024 \001(\r\022\023\n\013video_d"
  "elay\030\025 \001(\r\022\026\n\016channel_layout\030\026 \001(\004\022\020\n\010ch"
  "annels\030\027 \001(\r\022\023\n\013sample_rate\030\030 \001(\r\022\023\n\013blo"
  "ck_align\030\031 \001(\r\022\022\n\nframe_size\030\032 \001(\r\022\027\n\017in"
  "itial_padding\030\033 \001(\r\022\030\n\020trailing_padding\030"
  "\034 \001(\r\022\024\n\014seek_preroll\030\035 \001(\r\"\200\001\n\013MediaPac"
  "ket\022\021\n\tstream_id\030\001 \001(\r\022\013\n\003dts\030\002 \001(\004\022\022\n\np"
  "ts_offset\030\003 \001(\r\022\035\n\tframetype\030\004 \001(\0162\n.Fra"
  "meType\022\014\n\004data\030\005 \001(\014\022\020\n\010duration\030\006 \001(\r\"J"
  "\n\005Start\022\020\n\010start_ts\030\001 \001(\004\022\016\n\006tb_num\030\002 \001("
  "\r\022\016\n\006tb_den\030\003 \001(\r\022\017\n\007channel\030\004 \001(\t\"\006\n\004St"
  "op\"u\n\010GopSlice\022\016\n\006ts_num\030\001 \001(\003\022\016\n\006ts_den"
  "\030\002 \001(\003\022\024\n\014duration_num\030\003 \001(\003\022\024\n\014duration"
  "_den\030\004 \001(\003\022\035\n\007packets\030\005 \003(\0132\014.MediaPacke"
  "t\"\364\001\n\003Msg\022\027\n\004type\030\001 \001(\0162\t.Msg.Type\022\023\n\004st"
  "op\030\002 \001(\0132\005.Stop\022\025\n\005start\030\003 \001(\0132\006.Start\022\027"
  "\n\006stream\030\004 \001(\0132\007.Stream\022!\n\013mediapacket\030\005"
  " \001(\0132\014.MediaPacket\022\033\n\010gopslice\030\006 \001(\0132\t.G"
  "opSlice\"O\n\004Type\022\007\n\003Nop\020\000\022\t\n\005Start\020\001\022\010\n\004S"
  "top\020\002\022\n\n\006Stream\020\003\022\017\n\013MediaPacket\020\004\022\014\n\010Go"
  "pSlice\020\005*:\n\006PixFmt\022\013\n\007YUV420P\020\000\022\013\n\007UYVY4"
  "22\020\001\022\014\n\010YUVJ420P\020\002\022\010\n\004NV12\020\003* \n\tFrameTyp"
  "e\022\005\n\001I\020\000\022\005\n\001P\020\001\022\005\n\001B\020\002b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_messages1_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_messages1_2eproto = {
    false, false, 2470, descriptor_table_protodef_messages1_2eproto,
    "messages1.proto",
    &descriptor_table_messages1_2eproto_once, nullptr, 0, 14,
    schemas, file_default_instances, TableStruct_messages1_2eproto::offsets,
    file_level_metadata_messages1_2eproto, file_level_enum_descriptors_messages1_2eproto,
    file_level_service_descriptors_messages1_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_messages1_2eproto_getter() {
  return &descriptor_table_messages1_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_messages1_2eproto(&descriptor_table_messages1_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioMediaType_SampleFmt_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messages1_2eproto);
  return file_level_enum_descriptors_messages1_2eproto[0];
}
bool AudioMediaType_SampleFmt_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AudioMediaType_SampleFmt AudioMediaType::S16;
constexpr AudioMediaType_SampleFmt AudioMediaType::U8;
constexpr AudioMediaType_SampleFmt AudioMediaType::S32;
constexpr AudioMediaType_SampleFmt AudioMediaType::FLT;
constexpr AudioMediaType_SampleFmt AudioMediaType::DBL;
constexpr AudioMediaType_SampleFmt AudioMediaType::U8P;
constexpr AudioMediaType_SampleFmt AudioMediaType::S16P;
constexpr AudioMediaType_SampleFmt AudioMediaType::S32P;
constexpr AudioMediaType_SampleFmt AudioMediaType::FLTP;
constexpr AudioMediaType_SampleFmt AudioMediaType::DBLP;
constexpr AudioMediaType_SampleFmt AudioMediaType::SampleFmt_MIN;
constexpr AudioMediaType_SampleFmt AudioMediaType::SampleFmt_MAX;
constexpr int AudioMediaType::SampleFmt_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Stream_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messages1_2eproto);
  return file_level_enum_descriptors_messages1_2eproto[1];
}
bool Stream_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Stream_Type Stream::VIDEO;
constexpr Stream_Type Stream::AUDIO;
constexpr Stream_Type Stream::SUBTITLE;
constexpr Stream_Type Stream::DATA;
constexpr Stream_Type Stream::Type_MIN;
constexpr Stream_Type Stream::Type_MAX;
constexpr int Stream::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Msg_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messages1_2eproto);
  return file_level_enum_descriptors_messages1_2eproto[2];
}
bool Msg_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Msg_Type Msg::Nop;
constexpr Msg_Type Msg::Start;
constexpr Msg_Type Msg::Stop;
constexpr Msg_Type Msg::Stream;
constexpr Msg_Type Msg::MediaPacket;
constexpr Msg_Type Msg::GopSlice;
constexpr Msg_Type Msg::Type_MIN;
constexpr Msg_Type Msg::Type_MAX;
constexpr int Msg::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PixFmt_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messages1_2eproto);
  return file_level_enum_descriptors_messages1_2eproto[3];
}
bool PixFmt_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FrameType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messages1_2eproto);
  return file_level_enum_descriptors_messages1_2eproto[4];
}
bool FrameType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class VideoMediaType::_Internal {
 public:
};

VideoMediaType::VideoMediaType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VideoMediaType)
}
VideoMediaType::VideoMediaType(const VideoMediaType& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VideoMediaType* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.width_){}
    , decltype(_impl_.height_){}
    , decltype(_impl_.fps_num_){}
    , decltype(_impl_.fps_den_){}
    , decltype(_impl_.aspect_num_){}
    , decltype(_impl_.aspect_den_){}
    , decltype(_impl_.pix_fmt_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.width_, &from._impl_.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pix_fmt_) -
    reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.pix_fmt_));
  // @@protoc_insertion_point(copy_constructor:VideoMediaType)
}

inline void VideoMediaType::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.width_){0u}
    , decltype(_impl_.height_){0u}
    , decltype(_impl_.fps_num_){0u}
    , decltype(_impl_.fps_den_){0u}
    , decltype(_impl_.aspect_num_){0u}
    , decltype(_impl_.aspect_den_){0u}
    , decltype(_impl_.pix_fmt_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VideoMediaType::~VideoMediaType() {
  // @@protoc_insertion_point(destructor:VideoMediaType)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoMediaType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VideoMediaType::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VideoMediaType::Clear() {
// @@protoc_insertion_point(message_clear_start:VideoMediaType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.width_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.pix_fmt_) -
      reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.pix_fmt_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VideoMediaType::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 width = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 height = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 fps_num = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.fps_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 fps_den = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.fps_den_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 aspect_num = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.aspect_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 aspect_den = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.aspect_den_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .PixFmt pix_fmt = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_pix_fmt(static_cast<::PixFmt>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoMediaType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VideoMediaType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 width = 4;
  if (this->_internal_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_width(), target);
  }

  // uint32 height = 5;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_height(), target);
  }

  // uint32 fps_num = 6;
  if (this->_internal_fps_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_fps_num(), target);
  }

  // uint32 fps_den = 7;
  if (this->_internal_fps_den() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_fps_den(), target);
  }

  // uint32 aspect_num = 8;
  if (this->_internal_aspect_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_aspect_num(), target);
  }

  // uint32 aspect_den = 9;
  if (this->_internal_aspect_den() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_aspect_den(), target);
  }

  // .PixFmt pix_fmt = 10;
  if (this->_internal_pix_fmt() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_pix_fmt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VideoMediaType)
  return target;
}

size_t VideoMediaType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VideoMediaType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 width = 4;
  if (this->_internal_width() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_width());
  }

  // uint32 height = 5;
  if (this->_internal_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_height());
  }

  // uint32 fps_num = 6;
  if (this->_internal_fps_num() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fps_num());
  }

  // uint32 fps_den = 7;
  if (this->_internal_fps_den() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fps_den());
  }

  // uint32 aspect_num = 8;
  if (this->_internal_aspect_num() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_aspect_num());
  }

  // uint32 aspect_den = 9;
  if (this->_internal_aspect_den() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_aspect_den());
  }

  // .PixFmt pix_fmt = 10;
  if (this->_internal_pix_fmt() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_pix_fmt());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VideoMediaType::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VideoMediaType::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VideoMediaType::GetClassData() const { return &_class_data_; }


void VideoMediaType::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VideoMediaType*>(&to_msg);
  auto& from = static_cast<const VideoMediaType&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VideoMediaType)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_width() != 0) {
    _this->_internal_set_width(from._internal_width());
  }
  if (from._internal_height() != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  if (from._internal_fps_num() != 0) {
    _this->_internal_set_fps_num(from._internal_fps_num());
  }
  if (from._internal_fps_den() != 0) {
    _this->_internal_set_fps_den(from._internal_fps_den());
  }
  if (from._internal_aspect_num() != 0) {
    _this->_internal_set_aspect_num(from._internal_aspect_num());
  }
  if (from._internal_aspect_den() != 0) {
    _this->_internal_set_aspect_den(from._internal_aspect_den());
  }
  if (from._internal_pix_fmt() != 0) {
    _this->_internal_set_pix_fmt(from._internal_pix_fmt());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VideoMediaType::CopyFrom(const VideoMediaType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VideoMediaType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoMediaType::IsInitialized() const {
  return true;
}

void VideoMediaType::InternalSwap(VideoMediaType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VideoMediaType, _impl_.pix_fmt_)
      + sizeof(VideoMediaType::_impl_.pix_fmt_)
      - PROTOBUF_FIELD_OFFSET(VideoMediaType, _impl_.width_)>(
          reinterpret_cast<char*>(&_impl_.width_),
          reinterpret_cast<char*>(&other->_impl_.width_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VideoMediaType::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages1_2eproto_getter, &descriptor_table_messages1_2eproto_once,
      file_level_metadata_messages1_2eproto[0]);
}

// ===================================================================

class SubtitleMediaType_Pair::_Internal {
 public:
};

SubtitleMediaType_Pair::SubtitleMediaType_Pair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SubtitleMediaType.Pair)
}
SubtitleMediaType_Pair::SubtitleMediaType_Pair(const SubtitleMediaType_Pair& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubtitleMediaType_Pair* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:SubtitleMediaType.Pair)
}

inline void SubtitleMediaType_Pair::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SubtitleMediaType_Pair::~SubtitleMediaType_Pair() {
  // @@protoc_insertion_point(destructor:SubtitleMediaType.Pair)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubtitleMediaType_Pair::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.value_.Destroy();
}

void SubtitleMediaType_Pair::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubtitleMediaType_Pair::Clear() {
// @@protoc_insertion_point(message_clear_start:SubtitleMediaType.Pair)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.value_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubtitleMediaType_Pair::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SubtitleMediaType.Pair.key"));
        } else
          goto handle_unusual;
        continue;
      // string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SubtitleMediaType.Pair.value"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SubtitleMediaType_Pair::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SubtitleMediaType.Pair)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SubtitleMediaType.Pair.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // string value = 2;
  if (!this->_internal_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SubtitleMediaType.Pair.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SubtitleMediaType.Pair)
  return target;
}

size_t SubtitleMediaType_Pair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SubtitleMediaType.Pair)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // string value = 2;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubtitleMediaType_Pair::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubtitleMediaType_Pair::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubtitleMediaType_Pair::GetClassData() const { return &_class_data_; }


void SubtitleMediaType_Pair::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubtitleMediaType_Pair*>(&to_msg);
  auto& from = static_cast<const SubtitleMediaType_Pair&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SubtitleMediaType.Pair)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubtitleMediaType_Pair::CopyFrom(const SubtitleMediaType_Pair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SubtitleMediaType.Pair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubtitleMediaType_Pair::IsInitialized() const {
  return true;
}

void SubtitleMediaType_Pair::InternalSwap(SubtitleMediaType_Pair* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SubtitleMediaType_Pair::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages1_2eproto_getter, &descriptor_table_messages1_2eproto_once,
      file_level_metadata_messages1_2eproto[1]);
}

// ===================================================================

class SubtitleMediaType::_Internal {
 public:
};

SubtitleMediaType::SubtitleMediaType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SubtitleMediaType)
}
SubtitleMediaType::SubtitleMediaType(const SubtitleMediaType& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubtitleMediaType* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.metadata_){from._impl_.metadata_}
    , decltype(_impl_.header_){}
    , decltype(_impl_.aspect_num_){}
    , decltype(_impl_.aspect_den_){}
    , decltype(_impl_.width_){}
    , decltype(_impl_.height_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.header_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.header_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_header().empty()) {
    _this->_impl_.header_.Set(from._internal_header(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.aspect_num_, &from._impl_.aspect_num_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) -
    reinterpret_cast<char*>(&_impl_.aspect_num_)) + sizeof(_impl_.height_));
  // @@protoc_insertion_point(copy_constructor:SubtitleMediaType)
}

inline void SubtitleMediaType::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.metadata_){arena}
    , decltype(_impl_.header_){}
    , decltype(_impl_.aspect_num_){0u}
    , decltype(_impl_.aspect_den_){0u}
    , decltype(_impl_.width_){0u}
    , decltype(_impl_.height_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.header_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.header_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SubtitleMediaType::~SubtitleMediaType() {
  // @@protoc_insertion_point(destructor:SubtitleMediaType)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubtitleMediaType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.metadata_.~RepeatedPtrField();
  _impl_.header_.Destroy();
}

void SubtitleMediaType::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubtitleMediaType::Clear() {
// @@protoc_insertion_point(message_clear_start:SubtitleMediaType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.metadata_.Clear();
  _impl_.header_.ClearToEmpty();
  ::memset(&_impl_.aspect_num_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.height_) -
      reinterpret_cast<char*>(&_impl_.aspect_num_)) + sizeof(_impl_.height_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubtitleMediaType::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 aspect_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.aspect_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 aspect_den = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.aspect_den_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .SubtitleMediaType.Pair metadata = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_metadata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bytes header = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_header();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 width = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 height = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SubtitleMediaType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SubtitleMediaType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 aspect_num = 1;
  if (this->_internal_aspect_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_aspect_num(), target);
  }

  // uint32 aspect_den = 2;
  if (this->_internal_aspect_den() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_aspect_den(), target);
  }

  // repeated .SubtitleMediaType.Pair metadata = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_metadata_size()); i < n; i++) {
    const auto& repfield = this->_internal_metadata(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bytes header = 4;
  if (!this->_internal_header().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_header(), target);
  }

  // uint32 width = 5;
  if (this->_internal_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_width(), target);
  }

  // uint32 height = 6;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SubtitleMediaType)
  return target;
}

size_t SubtitleMediaType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SubtitleMediaType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SubtitleMediaType.Pair metadata = 3;
  total_size += 1UL * this->_internal_metadata_size();
  for (const auto& msg : this->_impl_.metadata_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bytes header = 4;
  if (!this->_internal_header().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_header());
  }

  // uint32 aspect_num = 1;
  if (this->_internal_aspect_num() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_aspect_num());
  }

  // uint32 aspect_den = 2;
  if (this->_internal_aspect_den() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_aspect_den());
  }

  // uint32 width = 5;
  if (this->_internal_width() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_width());
  }

  // uint32 height = 6;
  if (this->_internal_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_height());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubtitleMediaType::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubtitleMediaType::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubtitleMediaType::GetClassData() const { return &_class_data_; }


void SubtitleMediaType::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubtitleMediaType*>(&to_msg);
  auto& from = static_cast<const SubtitleMediaType&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SubtitleMediaType)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.metadata_.MergeFrom(from._impl_.metadata_);
  if (!from._internal_header().empty()) {
    _this->_internal_set_header(from._internal_header());
  }
  if (from._internal_aspect_num() != 0) {
    _this->_internal_set_aspect_num(from._internal_aspect_num());
  }
  if (from._internal_aspect_den() != 0) {
    _this->_internal_set_aspect_den(from._internal_aspect_den());
  }
  if (from._internal_width() != 0) {
    _this->_internal_set_width(from._internal_width());
  }
  if (from._internal_height() != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubtitleMediaType::CopyFrom(const SubtitleMediaType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SubtitleMediaType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubtitleMediaType::IsInitialized() const {
  return true;
}

void SubtitleMediaType::InternalSwap(SubtitleMediaType* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.metadata_.InternalSwap(&other->_impl_.metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.header_, lhs_arena,
      &other->_impl_.header_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SubtitleMediaType, _impl_.height_)
      + sizeof(SubtitleMediaType::_impl_.height_)
      - PROTOBUF_FIELD_OFFSET(SubtitleMediaType, _impl_.aspect_num_)>(
          reinterpret_cast<char*>(&_impl_.aspect_num_),
          reinterpret_cast<char*>(&other->_impl_.aspect_num_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SubtitleMediaType::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages1_2eproto_getter, &descriptor_table_messages1_2eproto_once,
      file_level_metadata_messages1_2eproto[2]);
}

// ===================================================================

class DataMediaType_Pair::_Internal {
 public:
};

DataMediaType_Pair::DataMediaType_Pair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:DataMediaType.Pair)
}
DataMediaType_Pair::DataMediaType_Pair(const DataMediaType_Pair& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DataMediaType_Pair* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:DataMediaType.Pair)
}

inline void DataMediaType_Pair::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DataMediaType_Pair::~DataMediaType_Pair() {
  // @@protoc_insertion_point(destructor:DataMediaType.Pair)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DataMediaType_Pair::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.value_.Destroy();
}

void DataMediaType_Pair::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DataMediaType_Pair::Clear() {
// @@protoc_insertion_point(message_clear_start:DataMediaType.Pair)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.value_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DataMediaType_Pair::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "DataMediaType.Pair.key"));
        } else
          goto handle_unusual;
        continue;
      // string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "DataMediaType.Pair.value"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DataMediaType_Pair::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DataMediaType.Pair)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DataMediaType.Pair.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // string value = 2;
  if (!this->_internal_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DataMediaType.Pair.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DataMediaType.Pair)
  return target;
}

size_t DataMediaType_Pair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DataMediaType.Pair)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // string value = 2;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DataMediaType_Pair::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DataMediaType_Pair::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DataMediaType_Pair::GetClassData() const { return &_class_data_; }


void DataMediaType_Pair::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DataMediaType_Pair*>(&to_msg);
  auto& from = static_cast<const DataMediaType_Pair&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:DataMediaType.Pair)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DataMediaType_Pair::CopyFrom(const DataMediaType_Pair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DataMediaType.Pair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataMediaType_Pair::IsInitialized() const {
  return true;
}

void DataMediaType_Pair::InternalSwap(DataMediaType_Pair* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DataMediaType_Pair::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages1_2eproto_getter, &descriptor_table_messages1_2eproto_once,
      file_level_metadata_messages1_2eproto[3]);
}

// ===================================================================

class DataMediaType::_Internal {
 public:
};

DataMediaType::DataMediaType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:DataMediaType)
}
DataMediaType::DataMediaType(const DataMediaType& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DataMediaType* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){from._impl_.info_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:DataMediaType)
}

inline void DataMediaType::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DataMediaType::~DataMediaType() {
  // @@protoc_insertion_point(destructor:DataMediaType)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DataMediaType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.info_.~RepeatedPtrField();
}

void DataMediaType::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DataMediaType::Clear() {
// @@protoc_insertion_point(message_clear_start:DataMediaType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.info_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DataMediaType::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .DataMediaType.Pair info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DataMediaType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DataMediaType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .DataMediaType.Pair info = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DataMediaType)
  return target;
}

size_t DataMediaType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DataMediaType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .DataMediaType.Pair info = 1;
  total_size += 1UL * this->_internal_info_size();
  for (const auto& msg : this->_impl_.info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DataMediaType::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DataMediaType::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DataMediaType::GetClassData() const { return &_class_data_; }


void DataMediaType::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DataMediaType*>(&to_msg);
  auto& from = static_cast<const DataMediaType&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:DataMediaType)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.info_.MergeFrom(from._impl_.info_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DataMediaType::CopyFrom(const DataMediaType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DataMediaType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataMediaType::IsInitialized() const {
  return true;
}

void DataMediaType::InternalSwap(DataMediaType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.info_.InternalSwap(&other->_impl_.info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DataMediaType::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages1_2eproto_getter, &descriptor_table_messages1_2eproto_once,
      file_level_metadata_messages1_2eproto[4]);
}

// ===================================================================

class AudioMediaType::_Internal {
 public:
};

AudioMediaType::AudioMediaType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:AudioMediaType)
}
AudioMediaType::AudioMediaType(const AudioMediaType& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AudioMediaType* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.layout_){}
    , decltype(_impl_.freq_){}
    , decltype(_impl_.nchan_){}
    , decltype(_impl_.ssize_){}
    , decltype(_impl_.sample_fmt_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.layout_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.layout_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_layout().empty()) {
    _this->_impl_.layout_.Set(from._internal_layout(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.freq_, &from._impl_.freq_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sample_fmt_) -
    reinterpret_cast<char*>(&_impl_.freq_)) + sizeof(_impl_.sample_fmt_));
  // @@protoc_insertion_point(copy_constructor:AudioMediaType)
}

inline void AudioMediaType::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.layout_){}
    , decltype(_impl_.freq_){0u}
    , decltype(_impl_.nchan_){0u}
    , decltype(_impl_.ssize_){0u}
    , decltype(_impl_.sample_fmt_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.layout_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.layout_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AudioMediaType::~AudioMediaType() {
  // @@protoc_insertion_point(destructor:AudioMediaType)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioMediaType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.layout_.Destroy();
}

void AudioMediaType::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AudioMediaType::Clear() {
// @@protoc_insertion_point(message_clear_start:AudioMediaType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.layout_.ClearToEmpty();
  ::memset(&_impl_.freq_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.sample_fmt_) -
      reinterpret_cast<char*>(&_impl_.freq_)) + sizeof(_impl_.sample_fmt_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AudioMediaType::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 freq = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.freq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 nchan = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.nchan_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 ssize = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.ssize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .AudioMediaType.SampleFmt sample_fmt = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_sample_fmt(static_cast<::AudioMediaType_SampleFmt>(val));
        } else
          goto handle_unusual;
        continue;
      // string layout = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_layout();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "AudioMediaType.layout"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioMediaType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AudioMediaType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 freq = 4;
  if (this->_internal_freq() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_freq(), target);
  }

  // uint32 nchan = 5;
  if (this->_internal_nchan() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_nchan(), target);
  }

  // uint32 ssize = 6;
  if (this->_internal_ssize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_ssize(), target);
  }

  // .AudioMediaType.SampleFmt sample_fmt = 7;
  if (this->_internal_sample_fmt() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_sample_fmt(), target);
  }

  // string layout = 8;
  if (!this->_internal_layout().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_layout().data(), static_cast<int>(this->_internal_layout().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "AudioMediaType.layout");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_layout(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AudioMediaType)
  return target;
}

size_t AudioMediaType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AudioMediaType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string layout = 8;
  if (!this->_internal_layout().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_layout());
  }

  // uint32 freq = 4;
  if (this->_internal_freq() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_freq());
  }

  // uint32 nchan = 5;
  if (this->_internal_nchan() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nchan());
  }

  // uint32 ssize = 6;
  if (this->_internal_ssize() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ssize());
  }

  // .AudioMediaType.SampleFmt sample_fmt = 7;
  if (this->_internal_sample_fmt() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_sample_fmt());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AudioMediaType::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AudioMediaType::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AudioMediaType::GetClassData() const { return &_class_data_; }


void AudioMediaType::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AudioMediaType*>(&to_msg);
  auto& from = static_cast<const AudioMediaType&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AudioMediaType)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_layout().empty()) {
    _this->_internal_set_layout(from._internal_layout());
  }
  if (from._internal_freq() != 0) {
    _this->_internal_set_freq(from._internal_freq());
  }
  if (from._internal_nchan() != 0) {
    _this->_internal_set_nchan(from._internal_nchan());
  }
  if (from._internal_ssize() != 0) {
    _this->_internal_set_ssize(from._internal_ssize());
  }
  if (from._internal_sample_fmt() != 0) {
    _this->_internal_set_sample_fmt(from._internal_sample_fmt());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AudioMediaType::CopyFrom(const AudioMediaType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AudioMediaType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioMediaType::IsInitialized() const {
  return true;
}

void AudioMediaType::InternalSwap(AudioMediaType* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.layout_, lhs_arena,
      &other->_impl_.layout_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioMediaType, _impl_.sample_fmt_)
      + sizeof(AudioMediaType::_impl_.sample_fmt_)
      - PROTOBUF_FIELD_OFFSET(AudioMediaType, _impl_.freq_)>(
          reinterpret_cast<char*>(&_impl_.freq_),
          reinterpret_cast<char*>(&other->_impl_.freq_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AudioMediaType::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages1_2eproto_getter, &descriptor_table_messages1_2eproto_once,
      file_level_metadata_messages1_2eproto[5]);
}

// ===================================================================

class Stream_Pair::_Internal {
 public:
};

Stream_Pair::Stream_Pair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Stream.Pair)
}
Stream_Pair::Stream_Pair(const Stream_Pair& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Stream_Pair* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Stream.Pair)
}

inline void Stream_Pair::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Stream_Pair::~Stream_Pair() {
  // @@protoc_insertion_point(destructor:Stream.Pair)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Stream_Pair::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.value_.Destroy();
}

void Stream_Pair::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Stream_Pair::Clear() {
// @@protoc_insertion_point(message_clear_start:Stream.Pair)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.value_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Stream_Pair::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Stream.Pair.key"));
        } else
          goto handle_unusual;
        continue;
      // string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Stream.Pair.value"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Stream_Pair::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Stream.Pair)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Stream.Pair.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // string value = 2;
  if (!this->_internal_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Stream.Pair.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Stream.Pair)
  return target;
}

size_t Stream_Pair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Stream.Pair)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // string value = 2;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Stream_Pair::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Stream_Pair::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Stream_Pair::GetClassData() const { return &_class_data_; }


void Stream_Pair::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Stream_Pair*>(&to_msg);
  auto& from = static_cast<const Stream_Pair&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Stream.Pair)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Stream_Pair::CopyFrom(const Stream_Pair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Stream.Pair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Stream_Pair::IsInitialized() const {
  return true;
}

void Stream_Pair::InternalSwap(Stream_Pair* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Stream_Pair::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages1_2eproto_getter, &descriptor_table_messages1_2eproto_once,
      file_level_metadata_messages1_2eproto[6]);
}

// ===================================================================

class Stream::_Internal {
 public:
  static const ::VideoMediaType& videomt(const Stream* msg);
  static const ::AudioMediaType& audiomt(const Stream* msg);
  static const ::SubtitleMediaType& subtitlemt(const Stream* msg);
  static const ::DataMediaType& datamt(const Stream* msg);
  static const ::CodecParameters& avparams(const Stream* msg);
};

const ::VideoMediaType&
Stream::_Internal::videomt(const Stream* msg) {
  return *msg->_impl_.videomt_;
}
const ::AudioMediaType&
Stream::_Internal::audiomt(const Stream* msg) {
  return *msg->_impl_.audiomt_;
}
const ::SubtitleMediaType&
Stream::_Internal::subtitlemt(const Stream* msg) {
  return *msg->_impl_.subtitlemt_;
}
const ::DataMediaType&
Stream::_Internal::datamt(const Stream* msg) {
  return *msg->_impl_.datamt_;
}
const ::CodecParameters&
Stream::_Internal::avparams(const Stream* msg) {
  return *msg->_impl_.avparams_;
}
Stream::Stream(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Stream)
}
Stream::Stream(const Stream& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Stream* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.metadata_){from._impl_.metadata_}
    , decltype(_impl_.codec_){}
    , decltype(_impl_.extradata_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.channel_){}
    , decltype(_impl_.videomt_){nullptr}
    , decltype(_impl_.audiomt_){nullptr}
    , decltype(_impl_.subtitlemt_){nullptr}
    , decltype(_impl_.datamt_){nullptr}
    , decltype(_impl_.avparams_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.bitrate_){}
    , decltype(_impl_.tb_num_){}
    , decltype(_impl_.tb_den_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.codec_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.codec_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_codec().empty()) {
    _this->_impl_.codec_.Set(from._internal_codec(), 
      _this->GetArenaForAllocation());
  }
  _impl_.extradata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extradata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_extradata().empty()) {
    _this->_impl_.extradata_.Set(from._internal_extradata(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.channel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.channel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_channel().empty()) {
    _this->_impl_.channel_.Set(from._internal_channel(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_videomt()) {
    _this->_impl_.videomt_ = new ::VideoMediaType(*from._impl_.videomt_);
  }
  if (from._internal_has_audiomt()) {
    _this->_impl_.audiomt_ = new ::AudioMediaType(*from._impl_.audiomt_);
  }
  if (from._internal_has_subtitlemt()) {
    _this->_impl_.subtitlemt_ = new ::SubtitleMediaType(*from._impl_.subtitlemt_);
  }
  if (from._internal_has_datamt()) {
    _this->_impl_.datamt_ = new ::DataMediaType(*from._impl_.datamt_);
  }
  if (from._internal_has_avparams()) {
    _this->_impl_.avparams_ = new ::CodecParameters(*from._impl_.avparams_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tb_den_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.tb_den_));
  // @@protoc_insertion_point(copy_constructor:Stream)
}

inline void Stream::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.metadata_){arena}
    , decltype(_impl_.codec_){}
    , decltype(_impl_.extradata_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.channel_){}
    , decltype(_impl_.videomt_){nullptr}
    , decltype(_impl_.audiomt_){nullptr}
    , decltype(_impl_.subtitlemt_){nullptr}
    , decltype(_impl_.datamt_){nullptr}
    , decltype(_impl_.avparams_){nullptr}
    , decltype(_impl_.id_){0u}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.bitrate_){0u}
    , decltype(_impl_.tb_num_){0u}
    , decltype(_impl_.tb_den_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.codec_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.codec_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.extradata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extradata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.channel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.channel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Stream::~Stream() {
  // @@protoc_insertion_point(destructor:Stream)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Stream::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.metadata_.~RepeatedPtrField();
  _impl_.codec_.Destroy();
  _impl_.extradata_.Destroy();
  _impl_.name_.Destroy();
  _impl_.channel_.Destroy();
  if (this != internal_default_instance()) delete _impl_.videomt_;
  if (this != internal_default_instance()) delete _impl_.audiomt_;
  if (this != internal_default_instance()) delete _impl_.subtitlemt_;
  if (this != internal_default_instance()) delete _impl_.datamt_;
  if (this != internal_default_instance()) delete _impl_.avparams_;
}

void Stream::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Stream::Clear() {
// @@protoc_insertion_point(message_clear_start:Stream)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.metadata_.Clear();
  _impl_.codec_.ClearToEmpty();
  _impl_.extradata_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  _impl_.channel_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.videomt_ != nullptr) {
    delete _impl_.videomt_;
  }
  _impl_.videomt_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.audiomt_ != nullptr) {
    delete _impl_.audiomt_;
  }
  _impl_.audiomt_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.subtitlemt_ != nullptr) {
    delete _impl_.subtitlemt_;
  }
  _impl_.subtitlemt_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.datamt_ != nullptr) {
    delete _impl_.datamt_;
  }
  _impl_.datamt_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.avparams_ != nullptr) {
    delete _impl_.avparams_;
  }
  _impl_.avparams_ = nullptr;
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.tb_den_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.tb_den_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Stream::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Stream.Type type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::Stream_Type>(val));
        } else
          goto handle_unusual;
        continue;
      // string codec = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_codec();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Stream.codec"));
        } else
          goto handle_unusual;
        continue;
      // uint32 bitrate = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.bitrate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 tb_num = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.tb_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 tb_den = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.tb_den_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes extradata = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_extradata();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .VideoMediaType videomt = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_videomt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .AudioMediaType audiomt = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_audiomt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Stream.name"));
        } else
          goto handle_unusual;
        continue;
      // string channel = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_channel();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Stream.channel"));
        } else
          goto handle_unusual;
        continue;
      // .SubtitleMediaType subtitlemt = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_subtitlemt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .DataMediaType datamt = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_datamt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Stream.Pair metadata = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_metadata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .CodecParameters avparams = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_avparams(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Stream::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Stream)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // .Stream.Type type = 2;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // string codec = 3;
  if (!this->_internal_codec().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_codec().data(), static_cast<int>(this->_internal_codec().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Stream.codec");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_codec(), target);
  }

  // uint32 bitrate = 4;
  if (this->_internal_bitrate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_bitrate(), target);
  }

  // uint32 tb_num = 5;
  if (this->_internal_tb_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_tb_num(), target);
  }

  // uint32 tb_den = 6;
  if (this->_internal_tb_den() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_tb_den(), target);
  }

  // bytes extradata = 7;
  if (!this->_internal_extradata().empty()) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_extradata(), target);
  }

  // .VideoMediaType videomt = 8;
  if (this->_internal_has_videomt()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::videomt(this),
        _Internal::videomt(this).GetCachedSize(), target, stream);
  }

  // .AudioMediaType audiomt = 9;
  if (this->_internal_has_audiomt()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::audiomt(this),
        _Internal::audiomt(this).GetCachedSize(), target, stream);
  }

  // string name = 10;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Stream.name");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_name(), target);
  }

  // string channel = 11;
  if (!this->_internal_channel().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_channel().data(), static_cast<int>(this->_internal_channel().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Stream.channel");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_channel(), target);
  }

  // .SubtitleMediaType subtitlemt = 12;
  if (this->_internal_has_subtitlemt()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::subtitlemt(this),
        _Internal::subtitlemt(this).GetCachedSize(), target, stream);
  }

  // .DataMediaType datamt = 13;
  if (this->_internal_has_datamt()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::datamt(this),
        _Internal::datamt(this).GetCachedSize(), target, stream);
  }

  // repeated .Stream.Pair metadata = 14;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_metadata_size()); i < n; i++) {
    const auto& repfield = this->_internal_metadata(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .CodecParameters avparams = 15;
  if (this->_internal_has_avparams()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::avparams(this),
        _Internal::avparams(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Stream)
  return target;
}

size_t Stream::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Stream)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Stream.Pair metadata = 14;
  total_size += 1UL * this->_internal_metadata_size();
  for (const auto& msg : this->_impl_.metadata_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string codec = 3;
  if (!this->_internal_codec().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_codec());
  }

  // bytes extradata = 7;
  if (!this->_internal_extradata().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_extradata());
  }

  // string name = 10;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string channel = 11;
  if (!this->_internal_channel().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_channel());
  }

  // .VideoMediaType videomt = 8;
  if (this->_internal_has_videomt()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.videomt_);
  }

  // .AudioMediaType audiomt = 9;
  if (this->_internal_has_audiomt()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.audiomt_);
  }

  // .SubtitleMediaType subtitlemt = 12;
  if (this->_internal_has_subtitlemt()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.subtitlemt_);
  }

  // .DataMediaType datamt = 13;
  if (this->_internal_has_datamt()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.datamt_);
  }

  // .CodecParameters avparams = 15;
  if (this->_internal_has_avparams()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.avparams_);
  }

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
  }

  // .Stream.Type type = 2;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // uint32 bitrate = 4;
  if (this->_internal_bitrate() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bitrate());
  }

  // uint32 tb_num = 5;
  if (this->_internal_tb_num() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tb_num());
  }

  // uint32 tb_den = 6;
  if (this->_internal_tb_den() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tb_den());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Stream::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Stream::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Stream::GetClassData() const { return &_class_data_; }


void Stream::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Stream*>(&to_msg);
  auto& from = static_cast<const Stream&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Stream)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.metadata_.MergeFrom(from._impl_.metadata_);
  if (!from._internal_codec().empty()) {
    _this->_internal_set_codec(from._internal_codec());
  }
  if (!from._internal_extradata().empty()) {
    _this->_internal_set_extradata(from._internal_extradata());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_channel().empty()) {
    _this->_internal_set_channel(from._internal_channel());
  }
  if (from._internal_has_videomt()) {
    _this->_internal_mutable_videomt()->::VideoMediaType::MergeFrom(
        from._internal_videomt());
  }
  if (from._internal_has_audiomt()) {
    _this->_internal_mutable_audiomt()->::AudioMediaType::MergeFrom(
        from._internal_audiomt());
  }
  if (from._internal_has_subtitlemt()) {
    _this->_internal_mutable_subtitlemt()->::SubtitleMediaType::MergeFrom(
        from._internal_subtitlemt());
  }
  if (from._internal_has_datamt()) {
    _this->_internal_mutable_datamt()->::DataMediaType::MergeFrom(
        from._internal_datamt());
  }
  if (from._internal_has_avparams()) {
    _this->_internal_mutable_avparams()->::CodecParameters::MergeFrom(
        from._internal_avparams());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_bitrate() != 0) {
    _this->_internal_set_bitrate(from._internal_bitrate());
  }
  if (from._internal_tb_num() != 0) {
    _this->_internal_set_tb_num(from._internal_tb_num());
  }
  if (from._internal_tb_den() != 0) {
    _this->_internal_set_tb_den(from._internal_tb_den());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Stream::CopyFrom(const Stream& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Stream)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Stream::IsInitialized() const {
  return true;
}

void Stream::InternalSwap(Stream* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.metadata_.InternalSwap(&other->_impl_.metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.codec_, lhs_arena,
      &other->_impl_.codec_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.extradata_, lhs_arena,
      &other->_impl_.extradata_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.channel_, lhs_arena,
      &other->_impl_.channel_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Stream, _impl_.tb_den_)
      + sizeof(Stream::_impl_.tb_den_)
      - PROTOBUF_FIELD_OFFSET(Stream, _impl_.videomt_)>(
          reinterpret_cast<char*>(&_impl_.videomt_),
          reinterpret_cast<char*>(&other->_impl_.videomt_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Stream::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages1_2eproto_getter, &descriptor_table_messages1_2eproto_once,
      file_level_metadata_messages1_2eproto[7]);
}

// ===================================================================

class CodecParameters::_Internal {
 public:
};

CodecParameters::CodecParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CodecParameters)
}
CodecParameters::CodecParameters(const CodecParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CodecParameters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.extradata_){}
    , decltype(_impl_.codec_type_){}
    , decltype(_impl_.codec_id_){}
    , decltype(_impl_.codec_tag_){}
    , decltype(_impl_.format_){}
    , decltype(_impl_.bit_rate_){}
    , decltype(_impl_.bits_per_coded_sample_){}
    , decltype(_impl_.bits_per_raw_sample_){}
    , decltype(_impl_.profile_){}
    , decltype(_impl_.level_){}
    , decltype(_impl_.width_){}
    , decltype(_impl_.height_){}
    , decltype(_impl_.sample_aspect_ratio_num_){}
    , decltype(_impl_.sample_aspect_ratio_den_){}
    , decltype(_impl_.field_order_){}
    , decltype(_impl_.color_range_){}
    , decltype(_impl_.color_primaries_){}
    , decltype(_impl_.color_trc_){}
    , decltype(_impl_.color_space_){}
    , decltype(_impl_.chroma_location_){}
    , decltype(_impl_.channel_layout_){}
    , decltype(_impl_.video_delay_){}
    , decltype(_impl_.channels_){}
    , decltype(_impl_.sample_rate_){}
    , decltype(_impl_.block_align_){}
    , decltype(_impl_.frame_size_){}
    , decltype(_impl_.initial_padding_){}
    , decltype(_impl_.trailing_padding_){}
    , decltype(_impl_.seek_preroll_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.extradata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extradata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_extradata().empty()) {
    _this->_impl_.extradata_.Set(from._internal_extradata(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.codec_type_, &from._impl_.codec_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.seek_preroll_) -
    reinterpret_cast<char*>(&_impl_.codec_type_)) + sizeof(_impl_.seek_preroll_));
  // @@protoc_insertion_point(copy_constructor:CodecParameters)
}

inline void CodecParameters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.extradata_){}
    , decltype(_impl_.codec_type_){0u}
    , decltype(_impl_.codec_id_){0u}
    , decltype(_impl_.codec_tag_){0u}
    , decltype(_impl_.format_){0u}
    , decltype(_impl_.bit_rate_){uint64_t{0u}}
    , decltype(_impl_.bits_per_coded_sample_){0u}
    , decltype(_impl_.bits_per_raw_sample_){0u}
    , decltype(_impl_.profile_){0u}
    , decltype(_impl_.level_){0u}
    , decltype(_impl_.width_){0u}
    , decltype(_impl_.height_){0u}
    , decltype(_impl_.sample_aspect_ratio_num_){0}
    , decltype(_impl_.sample_aspect_ratio_den_){0}
    , decltype(_impl_.field_order_){0u}
    , decltype(_impl_.color_range_){0u}
    , decltype(_impl_.color_primaries_){0u}
    , decltype(_impl_.color_trc_){0u}
    , decltype(_impl_.color_space_){0u}
    , decltype(_impl_.chroma_location_){0u}
    , decltype(_impl_.channel_layout_){uint64_t{0u}}
    , decltype(_impl_.video_delay_){0u}
    , decltype(_impl_.channels_){0u}
    , decltype(_impl_.sample_rate_){0u}
    , decltype(_impl_.block_align_){0u}
    , decltype(_impl_.frame_size_){0u}
    , decltype(_impl_.initial_padding_){0u}
    , decltype(_impl_.trailing_padding_){0u}
    , decltype(_impl_.seek_preroll_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.extradata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extradata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CodecParameters::~CodecParameters() {
  // @@protoc_insertion_point(destructor:CodecParameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CodecParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.extradata_.Destroy();
}

void CodecParameters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CodecParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:CodecParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extradata_.ClearToEmpty();
  ::memset(&_impl_.codec_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.seek_preroll_) -
      reinterpret_cast<char*>(&_impl_.codec_type_)) + sizeof(_impl_.seek_preroll_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CodecParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 codec_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.codec_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 codec_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.codec_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 codec_tag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.codec_tag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes extradata = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_extradata();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 format = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.format_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 bit_rate = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.bit_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 bits_per_coded_sample = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.bits_per_coded_sample_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 bits_per_raw_sample = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.bits_per_raw_sample_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 profile = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.profile_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 level = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 width = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 height = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 sample_aspect_ratio_num = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.sample_aspect_ratio_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 sample_aspect_ratio_den = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _impl_.sample_aspect_ratio_den_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 field_order = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _impl_.field_order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 color_range = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _impl_.color_range_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 color_primaries = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _impl_.color_primaries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 color_trc = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _impl_.color_trc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 color_space = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _impl_.color_space_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 chroma_location = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _impl_.chroma_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 video_delay = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _impl_.video_delay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 channel_layout = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _impl_.channel_layout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 channels = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _impl_.channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 sample_rate = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _impl_.sample_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 block_align = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _impl_.block_align_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 frame_size = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _impl_.frame_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 initial_padding = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _impl_.initial_padding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 trailing_padding = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _impl_.trailing_padding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 seek_preroll = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _impl_.seek_preroll_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CodecParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CodecParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 codec_type = 1;
  if (this->_internal_codec_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_codec_type(), target);
  }

  // uint32 codec_id = 2;
  if (this->_internal_codec_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_codec_id(), target);
  }

  // uint32 codec_tag = 3;
  if (this->_internal_codec_tag() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_codec_tag(), target);
  }

  // bytes extradata = 4;
  if (!this->_internal_extradata().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_extradata(), target);
  }

  // uint32 format = 5;
  if (this->_internal_format() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_format(), target);
  }

  // uint64 bit_rate = 6;
  if (this->_internal_bit_rate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_bit_rate(), target);
  }

  // uint32 bits_per_coded_sample = 7;
  if (this->_internal_bits_per_coded_sample() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_bits_per_coded_sample(), target);
  }

  // uint32 bits_per_raw_sample = 8;
  if (this->_internal_bits_per_raw_sample() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_bits_per_raw_sample(), target);
  }

  // uint32 profile = 9;
  if (this->_internal_profile() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_profile(), target);
  }

  // uint32 level = 10;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_level(), target);
  }

  // uint32 width = 11;
  if (this->_internal_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_width(), target);
  }

  // uint32 height = 12;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_height(), target);
  }

  // int32 sample_aspect_ratio_num = 13;
  if (this->_internal_sample_aspect_ratio_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(13, this->_internal_sample_aspect_ratio_num(), target);
  }

  // int32 sample_aspect_ratio_den = 14;
  if (this->_internal_sample_aspect_ratio_den() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_sample_aspect_ratio_den(), target);
  }

  // uint32 field_order = 15;
  if (this->_internal_field_order() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_field_order(), target);
  }

  // uint32 color_range = 16;
  if (this->_internal_color_range() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_color_range(), target);
  }

  // uint32 color_primaries = 17;
  if (this->_internal_color_primaries() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_color_primaries(), target);
  }

  // uint32 color_trc = 18;
  if (this->_internal_color_trc() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_color_trc(), target);
  }

  // uint32 color_space = 19;
  if (this->_internal_color_space() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_color_space(), target);
  }

  // uint32 chroma_location = 20;
  if (this->_internal_chroma_location() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_chroma_location(), target);
  }

  // uint32 video_delay = 21;
  if (this->_internal_video_delay() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_video_delay(), target);
  }

  // uint64 channel_layout = 22;
  if (this->_internal_channel_layout() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(22, this->_internal_channel_layout(), target);
  }

  // uint32 channels = 23;
  if (this->_internal_channels() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(23, this->_internal_channels(), target);
  }

  // uint32 sample_rate = 24;
  if (this->_internal_sample_rate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(24, this->_internal_sample_rate(), target);
  }

  // uint32 block_align = 25;
  if (this->_internal_block_align() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(25, this->_internal_block_align(), target);
  }

  // uint32 frame_size = 26;
  if (this->_internal_frame_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(26, this->_internal_frame_size(), target);
  }

  // uint32 initial_padding = 27;
  if (this->_internal_initial_padding() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(27, this->_internal_initial_padding(), target);
  }

  // uint32 trailing_padding = 28;
  if (this->_internal_trailing_padding() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(28, this->_internal_trailing_padding(), target);
  }

  // uint32 seek_preroll = 29;
  if (this->_internal_seek_preroll() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(29, this->_internal_seek_preroll(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CodecParameters)
  return target;
}

size_t CodecParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CodecParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes extradata = 4;
  if (!this->_internal_extradata().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_extradata());
  }

  // uint32 codec_type = 1;
  if (this->_internal_codec_type() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_codec_type());
  }

  // uint32 codec_id = 2;
  if (this->_internal_codec_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_codec_id());
  }

  // uint32 codec_tag = 3;
  if (this->_internal_codec_tag() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_codec_tag());
  }

  // uint32 format = 5;
  if (this->_internal_format() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_format());
  }

  // uint64 bit_rate = 6;
  if (this->_internal_bit_rate() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bit_rate());
  }

  // uint32 bits_per_coded_sample = 7;
  if (this->_internal_bits_per_coded_sample() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bits_per_coded_sample());
  }

  // uint32 bits_per_raw_sample = 8;
  if (this->_internal_bits_per_raw_sample() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bits_per_raw_sample());
  }

  // uint32 profile = 9;
  if (this->_internal_profile() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_profile());
  }

  // uint32 level = 10;
  if (this->_internal_level() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_level());
  }

  // uint32 width = 11;
  if (this->_internal_width() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_width());
  }

  // uint32 height = 12;
  if (this->_internal_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_height());
  }

  // int32 sample_aspect_ratio_num = 13;
  if (this->_internal_sample_aspect_ratio_num() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sample_aspect_ratio_num());
  }

  // int32 sample_aspect_ratio_den = 14;
  if (this->_internal_sample_aspect_ratio_den() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sample_aspect_ratio_den());
  }

  // uint32 field_order = 15;
  if (this->_internal_field_order() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_field_order());
  }

  // uint32 color_range = 16;
  if (this->_internal_color_range() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_color_range());
  }

  // uint32 color_primaries = 17;
  if (this->_internal_color_primaries() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_color_primaries());
  }

  // uint32 color_trc = 18;
  if (this->_internal_color_trc() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_color_trc());
  }

  // uint32 color_space = 19;
  if (this->_internal_color_space() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_color_space());
  }

  // uint32 chroma_location = 20;
  if (this->_internal_chroma_location() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_chroma_location());
  }

  // uint64 channel_layout = 22;
  if (this->_internal_channel_layout() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt64Size(
        this->_internal_channel_layout());
  }

  // uint32 video_delay = 21;
  if (this->_internal_video_delay() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_video_delay());
  }

  // uint32 channels = 23;
  if (this->_internal_channels() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_channels());
  }

  // uint32 sample_rate = 24;
  if (this->_internal_sample_rate() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_sample_rate());
  }

  // uint32 block_align = 25;
  if (this->_internal_block_align() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_block_align());
  }

  // uint32 frame_size = 26;
  if (this->_internal_frame_size() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_frame_size());
  }

  // uint32 initial_padding = 27;
  if (this->_internal_initial_padding() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_initial_padding());
  }

  // uint32 trailing_padding = 28;
  if (this->_internal_trailing_padding() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_trailing_padding());
  }

  // uint32 seek_preroll = 29;
  if (this->_internal_seek_preroll() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_seek_preroll());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CodecParameters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CodecParameters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CodecParameters::GetClassData() const { return &_class_data_; }


void CodecParameters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CodecParameters*>(&to_msg);
  auto& from = static_cast<const CodecParameters&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CodecParameters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_extradata().empty()) {
    _this->_internal_set_extradata(from._internal_extradata());
  }
  if (from._internal_codec_type() != 0) {
    _this->_internal_set_codec_type(from._internal_codec_type());
  }
  if (from._internal_codec_id() != 0) {
    _this->_internal_set_codec_id(from._internal_codec_id());
  }
  if (from._internal_codec_tag() != 0) {
    _this->_internal_set_codec_tag(from._internal_codec_tag());
  }
  if (from._internal_format() != 0) {
    _this->_internal_set_format(from._internal_format());
  }
  if (from._internal_bit_rate() != 0) {
    _this->_internal_set_bit_rate(from._internal_bit_rate());
  }
  if (from._internal_bits_per_coded_sample() != 0) {
    _this->_internal_set_bits_per_coded_sample(from._internal_bits_per_coded_sample());
  }
  if (from._internal_bits_per_raw_sample() != 0) {
    _this->_internal_set_bits_per_raw_sample(from._internal_bits_per_raw_sample());
  }
  if (from._internal_profile() != 0) {
    _this->_internal_set_profile(from._internal_profile());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  if (from._internal_width() != 0) {
    _this->_internal_set_width(from._internal_width());
  }
  if (from._internal_height() != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  if (from._internal_sample_aspect_ratio_num() != 0) {
    _this->_internal_set_sample_aspect_ratio_num(from._internal_sample_aspect_ratio_num());
  }
  if (from._internal_sample_aspect_ratio_den() != 0) {
    _this->_internal_set_sample_aspect_ratio_den(from._internal_sample_aspect_ratio_den());
  }
  if (from._internal_field_order() != 0) {
    _this->_internal_set_field_order(from._internal_field_order());
  }
  if (from._internal_color_range() != 0) {
    _this->_internal_set_color_range(from._internal_color_range());
  }
  if (from._internal_color_primaries() != 0) {
    _this->_internal_set_color_primaries(from._internal_color_primaries());
  }
  if (from._internal_color_trc() != 0) {
    _this->_internal_set_color_trc(from._internal_color_trc());
  }
  if (from._internal_color_space() != 0) {
    _this->_internal_set_color_space(from._internal_color_space());
  }
  if (from._internal_chroma_location() != 0) {
    _this->_internal_set_chroma_location(from._internal_chroma_location());
  }
  if (from._internal_channel_layout() != 0) {
    _this->_internal_set_channel_layout(from._internal_channel_layout());
  }
  if (from._internal_video_delay() != 0) {
    _this->_internal_set_video_delay(from._internal_video_delay());
  }
  if (from._internal_channels() != 0) {
    _this->_internal_set_channels(from._internal_channels());
  }
  if (from._internal_sample_rate() != 0) {
    _this->_internal_set_sample_rate(from._internal_sample_rate());
  }
  if (from._internal_block_align() != 0) {
    _this->_internal_set_block_align(from._internal_block_align());
  }
  if (from._internal_frame_size() != 0) {
    _this->_internal_set_frame_size(from._internal_frame_size());
  }
  if (from._internal_initial_padding() != 0) {
    _this->_internal_set_initial_padding(from._internal_initial_padding());
  }
  if (from._internal_trailing_padding() != 0) {
    _this->_internal_set_trailing_padding(from._internal_trailing_padding());
  }
  if (from._internal_seek_preroll() != 0) {
    _this->_internal_set_seek_preroll(from._internal_seek_preroll());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CodecParameters::CopyFrom(const CodecParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CodecParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CodecParameters::IsInitialized() const {
  return true;
}

void CodecParameters::InternalSwap(CodecParameters* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.extradata_, lhs_arena,
      &other->_impl_.extradata_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CodecParameters, _impl_.seek_preroll_)
      + sizeof(CodecParameters::_impl_.seek_preroll_)
      - PROTOBUF_FIELD_OFFSET(CodecParameters, _impl_.codec_type_)>(
          reinterpret_cast<char*>(&_impl_.codec_type_),
          reinterpret_cast<char*>(&other->_impl_.codec_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CodecParameters::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages1_2eproto_getter, &descriptor_table_messages1_2eproto_once,
      file_level_metadata_messages1_2eproto[8]);
}

// ===================================================================

class MediaPacket::_Internal {
 public:
};

MediaPacket::MediaPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:MediaPacket)
}
MediaPacket::MediaPacket(const MediaPacket& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MediaPacket* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.dts_){}
    , decltype(_impl_.stream_id_){}
    , decltype(_impl_.pts_offset_){}
    , decltype(_impl_.frametype_){}
    , decltype(_impl_.duration_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.dts_, &from._impl_.dts_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.duration_) -
    reinterpret_cast<char*>(&_impl_.dts_)) + sizeof(_impl_.duration_));
  // @@protoc_insertion_point(copy_constructor:MediaPacket)
}

inline void MediaPacket::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.dts_){uint64_t{0u}}
    , decltype(_impl_.stream_id_){0u}
    , decltype(_impl_.pts_offset_){0u}
    , decltype(_impl_.frametype_){0}
    , decltype(_impl_.duration_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MediaPacket::~MediaPacket() {
  // @@protoc_insertion_point(destructor:MediaPacket)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MediaPacket::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void MediaPacket::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MediaPacket::Clear() {
// @@protoc_insertion_point(message_clear_start:MediaPacket)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.ClearToEmpty();
  ::memset(&_impl_.dts_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.duration_) -
      reinterpret_cast<char*>(&_impl_.dts_)) + sizeof(_impl_.duration_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MediaPacket::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 stream_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.stream_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 dts = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.dts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 pts_offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.pts_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .FrameType frametype = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_frametype(static_cast<::FrameType>(val));
        } else
          goto handle_unusual;
        continue;
      // bytes data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 duration = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MediaPacket::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:MediaPacket)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 stream_id = 1;
  if (this->_internal_stream_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_stream_id(), target);
  }

  // uint64 dts = 2;
  if (this->_internal_dts() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_dts(), target);
  }

  // uint32 pts_offset = 3;
  if (this->_internal_pts_offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_pts_offset(), target);
  }

  // .FrameType frametype = 4;
  if (this->_internal_frametype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_frametype(), target);
  }

  // bytes data = 5;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_data(), target);
  }

  // uint32 duration = 6;
  if (this->_internal_duration() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_duration(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MediaPacket)
  return target;
}

size_t MediaPacket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MediaPacket)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 5;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // uint64 dts = 2;
  if (this->_internal_dts() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dts());
  }

  // uint32 stream_id = 1;
  if (this->_internal_stream_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stream_id());
  }

  // uint32 pts_offset = 3;
  if (this->_internal_pts_offset() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pts_offset());
  }

  // .FrameType frametype = 4;
  if (this->_internal_frametype() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_frametype());
  }

  // uint32 duration = 6;
  if (this->_internal_duration() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_duration());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MediaPacket::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MediaPacket::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MediaPacket::GetClassData() const { return &_class_data_; }


void MediaPacket::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MediaPacket*>(&to_msg);
  auto& from = static_cast<const MediaPacket&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:MediaPacket)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  if (from._internal_dts() != 0) {
    _this->_internal_set_dts(from._internal_dts());
  }
  if (from._internal_stream_id() != 0) {
    _this->_internal_set_stream_id(from._internal_stream_id());
  }
  if (from._internal_pts_offset() != 0) {
    _this->_internal_set_pts_offset(from._internal_pts_offset());
  }
  if (from._internal_frametype() != 0) {
    _this->_internal_set_frametype(from._internal_frametype());
  }
  if (from._internal_duration() != 0) {
    _this->_internal_set_duration(from._internal_duration());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MediaPacket::CopyFrom(const MediaPacket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MediaPacket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MediaPacket::IsInitialized() const {
  return true;
}

void MediaPacket::InternalSwap(MediaPacket* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MediaPacket, _impl_.duration_)
      + sizeof(MediaPacket::_impl_.duration_)
      - PROTOBUF_FIELD_OFFSET(MediaPacket, _impl_.dts_)>(
          reinterpret_cast<char*>(&_impl_.dts_),
          reinterpret_cast<char*>(&other->_impl_.dts_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MediaPacket::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages1_2eproto_getter, &descriptor_table_messages1_2eproto_once,
      file_level_metadata_messages1_2eproto[9]);
}

// ===================================================================

class Start::_Internal {
 public:
};

Start::Start(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Start)
}
Start::Start(const Start& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Start* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.channel_){}
    , decltype(_impl_.start_ts_){}
    , decltype(_impl_.tb_num_){}
    , decltype(_impl_.tb_den_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.channel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.channel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_channel().empty()) {
    _this->_impl_.channel_.Set(from._internal_channel(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.start_ts_, &from._impl_.start_ts_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tb_den_) -
    reinterpret_cast<char*>(&_impl_.start_ts_)) + sizeof(_impl_.tb_den_));
  // @@protoc_insertion_point(copy_constructor:Start)
}

inline void Start::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.channel_){}
    , decltype(_impl_.start_ts_){uint64_t{0u}}
    , decltype(_impl_.tb_num_){0u}
    , decltype(_impl_.tb_den_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.channel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.channel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Start::~Start() {
  // @@protoc_insertion_point(destructor:Start)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Start::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.channel_.Destroy();
}

void Start::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Start::Clear() {
// @@protoc_insertion_point(message_clear_start:Start)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.channel_.ClearToEmpty();
  ::memset(&_impl_.start_ts_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.tb_den_) -
      reinterpret_cast<char*>(&_impl_.start_ts_)) + sizeof(_impl_.tb_den_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Start::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 start_ts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.start_ts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 tb_num = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.tb_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 tb_den = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.tb_den_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string channel = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_channel();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Start.channel"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Start::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Start)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 start_ts = 1;
  if (this->_internal_start_ts() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_start_ts(), target);
  }

  // uint32 tb_num = 2;
  if (this->_internal_tb_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_tb_num(), target);
  }

  // uint32 tb_den = 3;
  if (this->_internal_tb_den() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_tb_den(), target);
  }

  // string channel = 4;
  if (!this->_internal_channel().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_channel().data(), static_cast<int>(this->_internal_channel().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Start.channel");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_channel(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Start)
  return target;
}

size_t Start::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Start)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string channel = 4;
  if (!this->_internal_channel().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_channel());
  }

  // uint64 start_ts = 1;
  if (this->_internal_start_ts() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_start_ts());
  }

  // uint32 tb_num = 2;
  if (this->_internal_tb_num() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tb_num());
  }

  // uint32 tb_den = 3;
  if (this->_internal_tb_den() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tb_den());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Start::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Start::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Start::GetClassData() const { return &_class_data_; }


void Start::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Start*>(&to_msg);
  auto& from = static_cast<const Start&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Start)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_channel().empty()) {
    _this->_internal_set_channel(from._internal_channel());
  }
  if (from._internal_start_ts() != 0) {
    _this->_internal_set_start_ts(from._internal_start_ts());
  }
  if (from._internal_tb_num() != 0) {
    _this->_internal_set_tb_num(from._internal_tb_num());
  }
  if (from._internal_tb_den() != 0) {
    _this->_internal_set_tb_den(from._internal_tb_den());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Start::CopyFrom(const Start& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Start)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Start::IsInitialized() const {
  return true;
}

void Start::InternalSwap(Start* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.channel_, lhs_arena,
      &other->_impl_.channel_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Start, _impl_.tb_den_)
      + sizeof(Start::_impl_.tb_den_)
      - PROTOBUF_FIELD_OFFSET(Start, _impl_.start_ts_)>(
          reinterpret_cast<char*>(&_impl_.start_ts_),
          reinterpret_cast<char*>(&other->_impl_.start_ts_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Start::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages1_2eproto_getter, &descriptor_table_messages1_2eproto_once,
      file_level_metadata_messages1_2eproto[10]);
}

// ===================================================================

class Stop::_Internal {
 public:
};

Stop::Stop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:Stop)
}
Stop::Stop(const Stop& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Stop* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Stop)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Stop::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Stop::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Stop::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages1_2eproto_getter, &descriptor_table_messages1_2eproto_once,
      file_level_metadata_messages1_2eproto[11]);
}

// ===================================================================

class GopSlice::_Internal {
 public:
};

GopSlice::GopSlice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:GopSlice)
}
GopSlice::GopSlice(const GopSlice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GopSlice* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.packets_){from._impl_.packets_}
    , decltype(_impl_.ts_num_){}
    , decltype(_impl_.ts_den_){}
    , decltype(_impl_.duration_num_){}
    , decltype(_impl_.duration_den_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.ts_num_, &from._impl_.ts_num_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.duration_den_) -
    reinterpret_cast<char*>(&_impl_.ts_num_)) + sizeof(_impl_.duration_den_));
  // @@protoc_insertion_point(copy_constructor:GopSlice)
}

inline void GopSlice::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.packets_){arena}
    , decltype(_impl_.ts_num_){int64_t{0}}
    , decltype(_impl_.ts_den_){int64_t{0}}
    , decltype(_impl_.duration_num_){int64_t{0}}
    , decltype(_impl_.duration_den_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GopSlice::~GopSlice() {
  // @@protoc_insertion_point(destructor:GopSlice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GopSlice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.packets_.~RepeatedPtrField();
}

void GopSlice::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GopSlice::Clear() {
// @@protoc_insertion_point(message_clear_start:GopSlice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.packets_.Clear();
  ::memset(&_impl_.ts_num_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.duration_den_) -
      reinterpret_cast<char*>(&_impl_.ts_num_)) + sizeof(_impl_.duration_den_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GopSlice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 ts_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.ts_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 ts_den = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.ts_den_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 duration_num = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.duration_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 duration_den = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.duration_den_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .MediaPacket packets = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_packets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GopSlice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:GopSlice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 ts_num = 1;
  if (this->_internal_ts_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_ts_num(), target);
  }

  // int64 ts_den = 2;
  if (this->_internal_ts_den() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_ts_den(), target);
  }

  // int64 duration_num = 3;
  if (this->_internal_duration_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_duration_num(), target);
  }

  // int64 duration_den = 4;
  if (this->_internal_duration_den() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_duration_den(), target);
  }

  // repeated .MediaPacket packets = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_packets_size()); i < n; i++) {
    const auto& repfield = this->_internal_packets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GopSlice)
  return target;
}

size_t GopSlice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GopSlice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .MediaPacket packets = 5;
  total_size += 1UL * this->_internal_packets_size();
  for (const auto& msg : this->_impl_.packets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int64 ts_num = 1;
  if (this->_internal_ts_num() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_ts_num());
  }

  // int64 ts_den = 2;
  if (this->_internal_ts_den() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_ts_den());
  }

  // int64 duration_num = 3;
  if (this->_internal_duration_num() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_duration_num());
  }

  // int64 duration_den = 4;
  if (this->_internal_duration_den() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_duration_den());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GopSlice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GopSlice::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GopSlice::GetClassData() const { return &_class_data_; }


void GopSlice::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GopSlice*>(&to_msg);
  auto& from = static_cast<const GopSlice&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:GopSlice)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.packets_.MergeFrom(from._impl_.packets_);
  if (from._internal_ts_num() != 0) {
    _this->_internal_set_ts_num(from._internal_ts_num());
  }
  if (from._internal_ts_den() != 0) {
    _this->_internal_set_ts_den(from._internal_ts_den());
  }
  if (from._internal_duration_num() != 0) {
    _this->_internal_set_duration_num(from._internal_duration_num());
  }
  if (from._internal_duration_den() != 0) {
    _this->_internal_set_duration_den(from._internal_duration_den());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GopSlice::CopyFrom(const GopSlice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GopSlice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GopSlice::IsInitialized() const {
  return true;
}

void GopSlice::InternalSwap(GopSlice* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.packets_.InternalSwap(&other->_impl_.packets_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GopSlice, _impl_.duration_den_)
      + sizeof(GopSlice::_impl_.duration_den_)
      - PROTOBUF_FIELD_OFFSET(GopSlice, _impl_.ts_num_)>(
          reinterpret_cast<char*>(&_impl_.ts_num_),
          reinterpret_cast<char*>(&other->_impl_.ts_num_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GopSlice::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages1_2eproto_getter, &descriptor_table_messages1_2eproto_once,
      file_level_metadata_messages1_2eproto[12]);
}

// ===================================================================

class Msg::_Internal {
 public:
  static const ::Stop& stop(const Msg* msg);
  static const ::Start& start(const Msg* msg);
  static const ::Stream& stream(const Msg* msg);
  static const ::MediaPacket& mediapacket(const Msg* msg);
  static const ::GopSlice& gopslice(const Msg* msg);
};

const ::Stop&
Msg::_Internal::stop(const Msg* msg) {
  return *msg->_impl_.stop_;
}
const ::Start&
Msg::_Internal::start(const Msg* msg) {
  return *msg->_impl_.start_;
}
const ::Stream&
Msg::_Internal::stream(const Msg* msg) {
  return *msg->_impl_.stream_;
}
const ::MediaPacket&
Msg::_Internal::mediapacket(const Msg* msg) {
  return *msg->_impl_.mediapacket_;
}
const ::GopSlice&
Msg::_Internal::gopslice(const Msg* msg) {
  return *msg->_impl_.gopslice_;
}
Msg::Msg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Msg)
}
Msg::Msg(const Msg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Msg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stop_){nullptr}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.stream_){nullptr}
    , decltype(_impl_.mediapacket_){nullptr}
    , decltype(_impl_.gopslice_){nullptr}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stop()) {
    _this->_impl_.stop_ = new ::Stop(*from._impl_.stop_);
  }
  if (from._internal_has_start()) {
    _this->_impl_.start_ = new ::Start(*from._impl_.start_);
  }
  if (from._internal_has_stream()) {
    _this->_impl_.stream_ = new ::Stream(*from._impl_.stream_);
  }
  if (from._internal_has_mediapacket()) {
    _this->_impl_.mediapacket_ = new ::MediaPacket(*from._impl_.mediapacket_);
  }
  if (from._internal_has_gopslice()) {
    _this->_impl_.gopslice_ = new ::GopSlice(*from._impl_.gopslice_);
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:Msg)
}

inline void Msg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stop_){nullptr}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.stream_){nullptr}
    , decltype(_impl_.mediapacket_){nullptr}
    , decltype(_impl_.gopslice_){nullptr}
    , decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Msg::~Msg() {
  // @@protoc_insertion_point(destructor:Msg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Msg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.stop_;
  if (this != internal_default_instance()) delete _impl_.start_;
  if (this != internal_default_instance()) delete _impl_.stream_;
  if (this != internal_default_instance()) delete _impl_.mediapacket_;
  if (this != internal_default_instance()) delete _impl_.gopslice_;
}

void Msg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Msg::Clear() {
// @@protoc_insertion_point(message_clear_start:Msg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.stop_ != nullptr) {
    delete _impl_.stop_;
  }
  _impl_.stop_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.start_ != nullptr) {
    delete _impl_.start_;
  }
  _impl_.start_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.stream_ != nullptr) {
    delete _impl_.stream_;
  }
  _impl_.stream_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.mediapacket_ != nullptr) {
    delete _impl_.mediapacket_;
  }
  _impl_.mediapacket_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.gopslice_ != nullptr) {
    delete _impl_.gopslice_;
  }
  _impl_.gopslice_ = nullptr;
  _impl_.type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Msg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Msg.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::Msg_Type>(val));
        } else
          goto handle_unusual;
        continue;
      // .Stop stop = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_stop(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Start start = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Stream stream = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_stream(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .MediaPacket mediapacket = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_mediapacket(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .GopSlice gopslice = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_gopslice(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Msg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Msg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Msg.Type type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // .Stop stop = 2;
  if (this->_internal_has_stop()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::stop(this),
        _Internal::stop(this).GetCachedSize(), target, stream);
  }

  // .Start start = 3;
  if (this->_internal_has_start()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::start(this),
        _Internal::start(this).GetCachedSize(), target, stream);
  }

  // .Stream stream = 4;
  if (this->_internal_has_stream()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::stream(this),
        _Internal::stream(this).GetCachedSize(), target, stream);
  }

  // .MediaPacket mediapacket = 5;
  if (this->_internal_has_mediapacket()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::mediapacket(this),
        _Internal::mediapacket(this).GetCachedSize(), target, stream);
  }

  // .GopSlice gopslice = 6;
  if (this->_internal_has_gopslice()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::gopslice(this),
        _Internal::gopslice(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Msg)
  return target;
}

size_t Msg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Msg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Stop stop = 2;
  if (this->_internal_has_stop()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stop_);
  }

  // .Start start = 3;
  if (this->_internal_has_start()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.start_);
  }

  // .Stream stream = 4;
  if (this->_internal_has_stream()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stream_);
  }

  // .MediaPacket mediapacket = 5;
  if (this->_internal_has_mediapacket()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.mediapacket_);
  }

  // .GopSlice gopslice = 6;
  if (this->_internal_has_gopslice()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.gopslice_);
  }

  // .Msg.Type type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Msg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Msg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Msg::GetClassData() const { return &_class_data_; }


void Msg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Msg*>(&to_msg);
  auto& from = static_cast<const Msg&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Msg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stop()) {
    _this->_internal_mutable_stop()->::Stop::MergeFrom(
        from._internal_stop());
  }
  if (from._internal_has_start()) {
    _this->_internal_mutable_start()->::Start::MergeFrom(
        from._internal_start());
  }
  if (from._internal_has_stream()) {
    _this->_internal_mutable_stream()->::Stream::MergeFrom(
        from._internal_stream());
  }
  if (from._internal_has_mediapacket()) {
    _this->_internal_mutable_mediapacket()->::MediaPacket::MergeFrom(
        from._internal_mediapacket());
  }
  if (from._internal_has_gopslice()) {
    _this->_internal_mutable_gopslice()->::GopSlice::MergeFrom(
        from._internal_gopslice());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Msg::CopyFrom(const Msg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Msg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Msg::IsInitialized() const {
  return true;
}

void Msg::InternalSwap(Msg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Msg, _impl_.type_)
      + sizeof(Msg::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(Msg, _impl_.stop_)>(
          reinterpret_cast<char*>(&_impl_.stop_),
          reinterpret_cast<char*>(&other->_impl_.stop_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Msg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages1_2eproto_getter, &descriptor_table_messages1_2eproto_once,
      file_level_metadata_messages1_2eproto[13]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::VideoMediaType*
Arena::CreateMaybeMessage< ::VideoMediaType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VideoMediaType >(arena);
}
template<> PROTOBUF_NOINLINE ::SubtitleMediaType_Pair*
Arena::CreateMaybeMessage< ::SubtitleMediaType_Pair >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SubtitleMediaType_Pair >(arena);
}
template<> PROTOBUF_NOINLINE ::SubtitleMediaType*
Arena::CreateMaybeMessage< ::SubtitleMediaType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SubtitleMediaType >(arena);
}
template<> PROTOBUF_NOINLINE ::DataMediaType_Pair*
Arena::CreateMaybeMessage< ::DataMediaType_Pair >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DataMediaType_Pair >(arena);
}
template<> PROTOBUF_NOINLINE ::DataMediaType*
Arena::CreateMaybeMessage< ::DataMediaType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DataMediaType >(arena);
}
template<> PROTOBUF_NOINLINE ::AudioMediaType*
Arena::CreateMaybeMessage< ::AudioMediaType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AudioMediaType >(arena);
}
template<> PROTOBUF_NOINLINE ::Stream_Pair*
Arena::CreateMaybeMessage< ::Stream_Pair >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Stream_Pair >(arena);
}
template<> PROTOBUF_NOINLINE ::Stream*
Arena::CreateMaybeMessage< ::Stream >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Stream >(arena);
}
template<> PROTOBUF_NOINLINE ::CodecParameters*
Arena::CreateMaybeMessage< ::CodecParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CodecParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::MediaPacket*
Arena::CreateMaybeMessage< ::MediaPacket >(Arena* arena) {
  return Arena::CreateMessageInternal< ::MediaPacket >(arena);
}
template<> PROTOBUF_NOINLINE ::Start*
Arena::CreateMaybeMessage< ::Start >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Start >(arena);
}
template<> PROTOBUF_NOINLINE ::Stop*
Arena::CreateMaybeMessage< ::Stop >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Stop >(arena);
}
template<> PROTOBUF_NOINLINE ::GopSlice*
Arena::CreateMaybeMessage< ::GopSlice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::GopSlice >(arena);
}
template<> PROTOBUF_NOINLINE ::Msg*
Arena::CreateMaybeMessage< ::Msg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Msg >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
