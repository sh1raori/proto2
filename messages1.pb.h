// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages1.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_messages1_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_messages1_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages1_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_messages1_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_messages1_2eproto;
class AudioMediaType;
struct AudioMediaTypeDefaultTypeInternal;
extern AudioMediaTypeDefaultTypeInternal _AudioMediaType_default_instance_;
class CodecParameters;
struct CodecParametersDefaultTypeInternal;
extern CodecParametersDefaultTypeInternal _CodecParameters_default_instance_;
class DataMediaType;
struct DataMediaTypeDefaultTypeInternal;
extern DataMediaTypeDefaultTypeInternal _DataMediaType_default_instance_;
class DataMediaType_Pair;
struct DataMediaType_PairDefaultTypeInternal;
extern DataMediaType_PairDefaultTypeInternal _DataMediaType_Pair_default_instance_;
class GopSlice;
struct GopSliceDefaultTypeInternal;
extern GopSliceDefaultTypeInternal _GopSlice_default_instance_;
class MediaPacket;
struct MediaPacketDefaultTypeInternal;
extern MediaPacketDefaultTypeInternal _MediaPacket_default_instance_;
class Msg;
struct MsgDefaultTypeInternal;
extern MsgDefaultTypeInternal _Msg_default_instance_;
class Start;
struct StartDefaultTypeInternal;
extern StartDefaultTypeInternal _Start_default_instance_;
class Stop;
struct StopDefaultTypeInternal;
extern StopDefaultTypeInternal _Stop_default_instance_;
class Stream;
struct StreamDefaultTypeInternal;
extern StreamDefaultTypeInternal _Stream_default_instance_;
class Stream_Pair;
struct Stream_PairDefaultTypeInternal;
extern Stream_PairDefaultTypeInternal _Stream_Pair_default_instance_;
class SubtitleMediaType;
struct SubtitleMediaTypeDefaultTypeInternal;
extern SubtitleMediaTypeDefaultTypeInternal _SubtitleMediaType_default_instance_;
class SubtitleMediaType_Pair;
struct SubtitleMediaType_PairDefaultTypeInternal;
extern SubtitleMediaType_PairDefaultTypeInternal _SubtitleMediaType_Pair_default_instance_;
class VideoMediaType;
struct VideoMediaTypeDefaultTypeInternal;
extern VideoMediaTypeDefaultTypeInternal _VideoMediaType_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AudioMediaType* Arena::CreateMaybeMessage<::AudioMediaType>(Arena*);
template<> ::CodecParameters* Arena::CreateMaybeMessage<::CodecParameters>(Arena*);
template<> ::DataMediaType* Arena::CreateMaybeMessage<::DataMediaType>(Arena*);
template<> ::DataMediaType_Pair* Arena::CreateMaybeMessage<::DataMediaType_Pair>(Arena*);
template<> ::GopSlice* Arena::CreateMaybeMessage<::GopSlice>(Arena*);
template<> ::MediaPacket* Arena::CreateMaybeMessage<::MediaPacket>(Arena*);
template<> ::Msg* Arena::CreateMaybeMessage<::Msg>(Arena*);
template<> ::Start* Arena::CreateMaybeMessage<::Start>(Arena*);
template<> ::Stop* Arena::CreateMaybeMessage<::Stop>(Arena*);
template<> ::Stream* Arena::CreateMaybeMessage<::Stream>(Arena*);
template<> ::Stream_Pair* Arena::CreateMaybeMessage<::Stream_Pair>(Arena*);
template<> ::SubtitleMediaType* Arena::CreateMaybeMessage<::SubtitleMediaType>(Arena*);
template<> ::SubtitleMediaType_Pair* Arena::CreateMaybeMessage<::SubtitleMediaType_Pair>(Arena*);
template<> ::VideoMediaType* Arena::CreateMaybeMessage<::VideoMediaType>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum AudioMediaType_SampleFmt : int {
  AudioMediaType_SampleFmt_S16 = 0,
  AudioMediaType_SampleFmt_U8 = 1,
  AudioMediaType_SampleFmt_S32 = 2,
  AudioMediaType_SampleFmt_FLT = 3,
  AudioMediaType_SampleFmt_DBL = 4,
  AudioMediaType_SampleFmt_U8P = 5,
  AudioMediaType_SampleFmt_S16P = 6,
  AudioMediaType_SampleFmt_S32P = 7,
  AudioMediaType_SampleFmt_FLTP = 8,
  AudioMediaType_SampleFmt_DBLP = 9,
  AudioMediaType_SampleFmt_AudioMediaType_SampleFmt_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AudioMediaType_SampleFmt_AudioMediaType_SampleFmt_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AudioMediaType_SampleFmt_IsValid(int value);
constexpr AudioMediaType_SampleFmt AudioMediaType_SampleFmt_SampleFmt_MIN = AudioMediaType_SampleFmt_S16;
constexpr AudioMediaType_SampleFmt AudioMediaType_SampleFmt_SampleFmt_MAX = AudioMediaType_SampleFmt_DBLP;
constexpr int AudioMediaType_SampleFmt_SampleFmt_ARRAYSIZE = AudioMediaType_SampleFmt_SampleFmt_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioMediaType_SampleFmt_descriptor();
template<typename T>
inline const std::string& AudioMediaType_SampleFmt_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioMediaType_SampleFmt>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioMediaType_SampleFmt_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioMediaType_SampleFmt_descriptor(), enum_t_value);
}
inline bool AudioMediaType_SampleFmt_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioMediaType_SampleFmt* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioMediaType_SampleFmt>(
    AudioMediaType_SampleFmt_descriptor(), name, value);
}
enum Stream_Type : int {
  Stream_Type_VIDEO = 0,
  Stream_Type_AUDIO = 1,
  Stream_Type_SUBTITLE = 2,
  Stream_Type_DATA = 3,
  Stream_Type_Stream_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Stream_Type_Stream_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Stream_Type_IsValid(int value);
constexpr Stream_Type Stream_Type_Type_MIN = Stream_Type_VIDEO;
constexpr Stream_Type Stream_Type_Type_MAX = Stream_Type_DATA;
constexpr int Stream_Type_Type_ARRAYSIZE = Stream_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Stream_Type_descriptor();
template<typename T>
inline const std::string& Stream_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Stream_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Stream_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Stream_Type_descriptor(), enum_t_value);
}
inline bool Stream_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Stream_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Stream_Type>(
    Stream_Type_descriptor(), name, value);
}
enum Msg_Type : int {
  Msg_Type_Nop = 0,
  Msg_Type_Start = 1,
  Msg_Type_Stop = 2,
  Msg_Type_Stream = 3,
  Msg_Type_MediaPacket = 4,
  Msg_Type_GopSlice = 5,
  Msg_Type_Msg_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Msg_Type_Msg_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Msg_Type_IsValid(int value);
constexpr Msg_Type Msg_Type_Type_MIN = Msg_Type_Nop;
constexpr Msg_Type Msg_Type_Type_MAX = Msg_Type_GopSlice;
constexpr int Msg_Type_Type_ARRAYSIZE = Msg_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Msg_Type_descriptor();
template<typename T>
inline const std::string& Msg_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Msg_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Msg_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Msg_Type_descriptor(), enum_t_value);
}
inline bool Msg_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Msg_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Msg_Type>(
    Msg_Type_descriptor(), name, value);
}
enum PixFmt : int {
  YUV420P = 0,
  UYVY422 = 1,
  YUVJ420P = 2,
  NV12 = 3,
  PixFmt_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PixFmt_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PixFmt_IsValid(int value);
constexpr PixFmt PixFmt_MIN = YUV420P;
constexpr PixFmt PixFmt_MAX = NV12;
constexpr int PixFmt_ARRAYSIZE = PixFmt_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PixFmt_descriptor();
template<typename T>
inline const std::string& PixFmt_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PixFmt>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PixFmt_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PixFmt_descriptor(), enum_t_value);
}
inline bool PixFmt_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PixFmt* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PixFmt>(
    PixFmt_descriptor(), name, value);
}
enum FrameType : int {
  I = 0,
  P = 1,
  B = 2,
  FrameType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FrameType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FrameType_IsValid(int value);
constexpr FrameType FrameType_MIN = I;
constexpr FrameType FrameType_MAX = B;
constexpr int FrameType_ARRAYSIZE = FrameType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FrameType_descriptor();
template<typename T>
inline const std::string& FrameType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FrameType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FrameType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FrameType_descriptor(), enum_t_value);
}
inline bool FrameType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FrameType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FrameType>(
    FrameType_descriptor(), name, value);
}
// ===================================================================

class VideoMediaType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VideoMediaType) */ {
 public:
  inline VideoMediaType() : VideoMediaType(nullptr) {}
  ~VideoMediaType() override;
  explicit PROTOBUF_CONSTEXPR VideoMediaType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoMediaType(const VideoMediaType& from);
  VideoMediaType(VideoMediaType&& from) noexcept
    : VideoMediaType() {
    *this = ::std::move(from);
  }

  inline VideoMediaType& operator=(const VideoMediaType& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoMediaType& operator=(VideoMediaType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoMediaType& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoMediaType* internal_default_instance() {
    return reinterpret_cast<const VideoMediaType*>(
               &_VideoMediaType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(VideoMediaType& a, VideoMediaType& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoMediaType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoMediaType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoMediaType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoMediaType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoMediaType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoMediaType& from) {
    VideoMediaType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoMediaType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VideoMediaType";
  }
  protected:
  explicit VideoMediaType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 4,
    kHeightFieldNumber = 5,
    kFpsNumFieldNumber = 6,
    kFpsDenFieldNumber = 7,
    kAspectNumFieldNumber = 8,
    kAspectDenFieldNumber = 9,
    kPixFmtFieldNumber = 10,
  };
  // uint32 width = 4;
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // uint32 height = 5;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // uint32 fps_num = 6;
  void clear_fps_num();
  uint32_t fps_num() const;
  void set_fps_num(uint32_t value);
  private:
  uint32_t _internal_fps_num() const;
  void _internal_set_fps_num(uint32_t value);
  public:

  // uint32 fps_den = 7;
  void clear_fps_den();
  uint32_t fps_den() const;
  void set_fps_den(uint32_t value);
  private:
  uint32_t _internal_fps_den() const;
  void _internal_set_fps_den(uint32_t value);
  public:

  // uint32 aspect_num = 8;
  void clear_aspect_num();
  uint32_t aspect_num() const;
  void set_aspect_num(uint32_t value);
  private:
  uint32_t _internal_aspect_num() const;
  void _internal_set_aspect_num(uint32_t value);
  public:

  // uint32 aspect_den = 9;
  void clear_aspect_den();
  uint32_t aspect_den() const;
  void set_aspect_den(uint32_t value);
  private:
  uint32_t _internal_aspect_den() const;
  void _internal_set_aspect_den(uint32_t value);
  public:

  // .PixFmt pix_fmt = 10;
  void clear_pix_fmt();
  ::PixFmt pix_fmt() const;
  void set_pix_fmt(::PixFmt value);
  private:
  ::PixFmt _internal_pix_fmt() const;
  void _internal_set_pix_fmt(::PixFmt value);
  public:

  // @@protoc_insertion_point(class_scope:VideoMediaType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t width_;
    uint32_t height_;
    uint32_t fps_num_;
    uint32_t fps_den_;
    uint32_t aspect_num_;
    uint32_t aspect_den_;
    int pix_fmt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages1_2eproto;
};
// -------------------------------------------------------------------

class SubtitleMediaType_Pair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SubtitleMediaType.Pair) */ {
 public:
  inline SubtitleMediaType_Pair() : SubtitleMediaType_Pair(nullptr) {}
  ~SubtitleMediaType_Pair() override;
  explicit PROTOBUF_CONSTEXPR SubtitleMediaType_Pair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubtitleMediaType_Pair(const SubtitleMediaType_Pair& from);
  SubtitleMediaType_Pair(SubtitleMediaType_Pair&& from) noexcept
    : SubtitleMediaType_Pair() {
    *this = ::std::move(from);
  }

  inline SubtitleMediaType_Pair& operator=(const SubtitleMediaType_Pair& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubtitleMediaType_Pair& operator=(SubtitleMediaType_Pair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubtitleMediaType_Pair& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubtitleMediaType_Pair* internal_default_instance() {
    return reinterpret_cast<const SubtitleMediaType_Pair*>(
               &_SubtitleMediaType_Pair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SubtitleMediaType_Pair& a, SubtitleMediaType_Pair& b) {
    a.Swap(&b);
  }
  inline void Swap(SubtitleMediaType_Pair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubtitleMediaType_Pair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubtitleMediaType_Pair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubtitleMediaType_Pair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubtitleMediaType_Pair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubtitleMediaType_Pair& from) {
    SubtitleMediaType_Pair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubtitleMediaType_Pair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SubtitleMediaType.Pair";
  }
  protected:
  explicit SubtitleMediaType_Pair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:SubtitleMediaType.Pair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages1_2eproto;
};
// -------------------------------------------------------------------

class SubtitleMediaType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SubtitleMediaType) */ {
 public:
  inline SubtitleMediaType() : SubtitleMediaType(nullptr) {}
  ~SubtitleMediaType() override;
  explicit PROTOBUF_CONSTEXPR SubtitleMediaType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubtitleMediaType(const SubtitleMediaType& from);
  SubtitleMediaType(SubtitleMediaType&& from) noexcept
    : SubtitleMediaType() {
    *this = ::std::move(from);
  }

  inline SubtitleMediaType& operator=(const SubtitleMediaType& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubtitleMediaType& operator=(SubtitleMediaType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubtitleMediaType& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubtitleMediaType* internal_default_instance() {
    return reinterpret_cast<const SubtitleMediaType*>(
               &_SubtitleMediaType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SubtitleMediaType& a, SubtitleMediaType& b) {
    a.Swap(&b);
  }
  inline void Swap(SubtitleMediaType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubtitleMediaType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubtitleMediaType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubtitleMediaType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubtitleMediaType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubtitleMediaType& from) {
    SubtitleMediaType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubtitleMediaType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SubtitleMediaType";
  }
  protected:
  explicit SubtitleMediaType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SubtitleMediaType_Pair Pair;

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 3,
    kHeaderFieldNumber = 4,
    kAspectNumFieldNumber = 1,
    kAspectDenFieldNumber = 2,
    kWidthFieldNumber = 5,
    kHeightFieldNumber = 6,
  };
  // repeated .SubtitleMediaType.Pair metadata = 3;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  ::SubtitleMediaType_Pair* mutable_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SubtitleMediaType_Pair >*
      mutable_metadata();
  private:
  const ::SubtitleMediaType_Pair& _internal_metadata(int index) const;
  ::SubtitleMediaType_Pair* _internal_add_metadata();
  public:
  const ::SubtitleMediaType_Pair& metadata(int index) const;
  ::SubtitleMediaType_Pair* add_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SubtitleMediaType_Pair >&
      metadata() const;

  // bytes header = 4;
  void clear_header();
  const std::string& header() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_header(ArgT0&& arg0, ArgT... args);
  std::string* mutable_header();
  PROTOBUF_NODISCARD std::string* release_header();
  void set_allocated_header(std::string* header);
  private:
  const std::string& _internal_header() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_header(const std::string& value);
  std::string* _internal_mutable_header();
  public:

  // uint32 aspect_num = 1;
  void clear_aspect_num();
  uint32_t aspect_num() const;
  void set_aspect_num(uint32_t value);
  private:
  uint32_t _internal_aspect_num() const;
  void _internal_set_aspect_num(uint32_t value);
  public:

  // uint32 aspect_den = 2;
  void clear_aspect_den();
  uint32_t aspect_den() const;
  void set_aspect_den(uint32_t value);
  private:
  uint32_t _internal_aspect_den() const;
  void _internal_set_aspect_den(uint32_t value);
  public:

  // uint32 width = 5;
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // uint32 height = 6;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SubtitleMediaType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SubtitleMediaType_Pair > metadata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr header_;
    uint32_t aspect_num_;
    uint32_t aspect_den_;
    uint32_t width_;
    uint32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages1_2eproto;
};
// -------------------------------------------------------------------

class DataMediaType_Pair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DataMediaType.Pair) */ {
 public:
  inline DataMediaType_Pair() : DataMediaType_Pair(nullptr) {}
  ~DataMediaType_Pair() override;
  explicit PROTOBUF_CONSTEXPR DataMediaType_Pair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataMediaType_Pair(const DataMediaType_Pair& from);
  DataMediaType_Pair(DataMediaType_Pair&& from) noexcept
    : DataMediaType_Pair() {
    *this = ::std::move(from);
  }

  inline DataMediaType_Pair& operator=(const DataMediaType_Pair& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMediaType_Pair& operator=(DataMediaType_Pair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataMediaType_Pair& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataMediaType_Pair* internal_default_instance() {
    return reinterpret_cast<const DataMediaType_Pair*>(
               &_DataMediaType_Pair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DataMediaType_Pair& a, DataMediaType_Pair& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMediaType_Pair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMediaType_Pair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataMediaType_Pair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataMediaType_Pair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataMediaType_Pair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataMediaType_Pair& from) {
    DataMediaType_Pair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataMediaType_Pair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DataMediaType.Pair";
  }
  protected:
  explicit DataMediaType_Pair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:DataMediaType.Pair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages1_2eproto;
};
// -------------------------------------------------------------------

class DataMediaType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DataMediaType) */ {
 public:
  inline DataMediaType() : DataMediaType(nullptr) {}
  ~DataMediaType() override;
  explicit PROTOBUF_CONSTEXPR DataMediaType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataMediaType(const DataMediaType& from);
  DataMediaType(DataMediaType&& from) noexcept
    : DataMediaType() {
    *this = ::std::move(from);
  }

  inline DataMediaType& operator=(const DataMediaType& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMediaType& operator=(DataMediaType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataMediaType& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataMediaType* internal_default_instance() {
    return reinterpret_cast<const DataMediaType*>(
               &_DataMediaType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DataMediaType& a, DataMediaType& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMediaType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMediaType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataMediaType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataMediaType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataMediaType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataMediaType& from) {
    DataMediaType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataMediaType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DataMediaType";
  }
  protected:
  explicit DataMediaType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DataMediaType_Pair Pair;

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // repeated .DataMediaType.Pair info = 1;
  int info_size() const;
  private:
  int _internal_info_size() const;
  public:
  void clear_info();
  ::DataMediaType_Pair* mutable_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataMediaType_Pair >*
      mutable_info();
  private:
  const ::DataMediaType_Pair& _internal_info(int index) const;
  ::DataMediaType_Pair* _internal_add_info();
  public:
  const ::DataMediaType_Pair& info(int index) const;
  ::DataMediaType_Pair* add_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataMediaType_Pair >&
      info() const;

  // @@protoc_insertion_point(class_scope:DataMediaType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataMediaType_Pair > info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages1_2eproto;
};
// -------------------------------------------------------------------

class AudioMediaType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AudioMediaType) */ {
 public:
  inline AudioMediaType() : AudioMediaType(nullptr) {}
  ~AudioMediaType() override;
  explicit PROTOBUF_CONSTEXPR AudioMediaType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioMediaType(const AudioMediaType& from);
  AudioMediaType(AudioMediaType&& from) noexcept
    : AudioMediaType() {
    *this = ::std::move(from);
  }

  inline AudioMediaType& operator=(const AudioMediaType& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioMediaType& operator=(AudioMediaType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioMediaType& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioMediaType* internal_default_instance() {
    return reinterpret_cast<const AudioMediaType*>(
               &_AudioMediaType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AudioMediaType& a, AudioMediaType& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioMediaType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioMediaType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioMediaType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioMediaType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioMediaType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioMediaType& from) {
    AudioMediaType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioMediaType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AudioMediaType";
  }
  protected:
  explicit AudioMediaType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AudioMediaType_SampleFmt SampleFmt;
  static constexpr SampleFmt S16 =
    AudioMediaType_SampleFmt_S16;
  static constexpr SampleFmt U8 =
    AudioMediaType_SampleFmt_U8;
  static constexpr SampleFmt S32 =
    AudioMediaType_SampleFmt_S32;
  static constexpr SampleFmt FLT =
    AudioMediaType_SampleFmt_FLT;
  static constexpr SampleFmt DBL =
    AudioMediaType_SampleFmt_DBL;
  static constexpr SampleFmt U8P =
    AudioMediaType_SampleFmt_U8P;
  static constexpr SampleFmt S16P =
    AudioMediaType_SampleFmt_S16P;
  static constexpr SampleFmt S32P =
    AudioMediaType_SampleFmt_S32P;
  static constexpr SampleFmt FLTP =
    AudioMediaType_SampleFmt_FLTP;
  static constexpr SampleFmt DBLP =
    AudioMediaType_SampleFmt_DBLP;
  static inline bool SampleFmt_IsValid(int value) {
    return AudioMediaType_SampleFmt_IsValid(value);
  }
  static constexpr SampleFmt SampleFmt_MIN =
    AudioMediaType_SampleFmt_SampleFmt_MIN;
  static constexpr SampleFmt SampleFmt_MAX =
    AudioMediaType_SampleFmt_SampleFmt_MAX;
  static constexpr int SampleFmt_ARRAYSIZE =
    AudioMediaType_SampleFmt_SampleFmt_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SampleFmt_descriptor() {
    return AudioMediaType_SampleFmt_descriptor();
  }
  template<typename T>
  static inline const std::string& SampleFmt_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SampleFmt>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SampleFmt_Name.");
    return AudioMediaType_SampleFmt_Name(enum_t_value);
  }
  static inline bool SampleFmt_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SampleFmt* value) {
    return AudioMediaType_SampleFmt_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLayoutFieldNumber = 8,
    kFreqFieldNumber = 4,
    kNchanFieldNumber = 5,
    kSsizeFieldNumber = 6,
    kSampleFmtFieldNumber = 7,
  };
  // string layout = 8;
  void clear_layout();
  const std::string& layout() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_layout(ArgT0&& arg0, ArgT... args);
  std::string* mutable_layout();
  PROTOBUF_NODISCARD std::string* release_layout();
  void set_allocated_layout(std::string* layout);
  private:
  const std::string& _internal_layout() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_layout(const std::string& value);
  std::string* _internal_mutable_layout();
  public:

  // uint32 freq = 4;
  void clear_freq();
  uint32_t freq() const;
  void set_freq(uint32_t value);
  private:
  uint32_t _internal_freq() const;
  void _internal_set_freq(uint32_t value);
  public:

  // uint32 nchan = 5;
  void clear_nchan();
  uint32_t nchan() const;
  void set_nchan(uint32_t value);
  private:
  uint32_t _internal_nchan() const;
  void _internal_set_nchan(uint32_t value);
  public:

  // uint32 ssize = 6;
  void clear_ssize();
  uint32_t ssize() const;
  void set_ssize(uint32_t value);
  private:
  uint32_t _internal_ssize() const;
  void _internal_set_ssize(uint32_t value);
  public:

  // .AudioMediaType.SampleFmt sample_fmt = 7;
  void clear_sample_fmt();
  ::AudioMediaType_SampleFmt sample_fmt() const;
  void set_sample_fmt(::AudioMediaType_SampleFmt value);
  private:
  ::AudioMediaType_SampleFmt _internal_sample_fmt() const;
  void _internal_set_sample_fmt(::AudioMediaType_SampleFmt value);
  public:

  // @@protoc_insertion_point(class_scope:AudioMediaType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr layout_;
    uint32_t freq_;
    uint32_t nchan_;
    uint32_t ssize_;
    int sample_fmt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages1_2eproto;
};
// -------------------------------------------------------------------

class Stream_Pair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Stream.Pair) */ {
 public:
  inline Stream_Pair() : Stream_Pair(nullptr) {}
  ~Stream_Pair() override;
  explicit PROTOBUF_CONSTEXPR Stream_Pair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stream_Pair(const Stream_Pair& from);
  Stream_Pair(Stream_Pair&& from) noexcept
    : Stream_Pair() {
    *this = ::std::move(from);
  }

  inline Stream_Pair& operator=(const Stream_Pair& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stream_Pair& operator=(Stream_Pair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stream_Pair& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stream_Pair* internal_default_instance() {
    return reinterpret_cast<const Stream_Pair*>(
               &_Stream_Pair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Stream_Pair& a, Stream_Pair& b) {
    a.Swap(&b);
  }
  inline void Swap(Stream_Pair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stream_Pair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stream_Pair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stream_Pair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stream_Pair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Stream_Pair& from) {
    Stream_Pair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stream_Pair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Stream.Pair";
  }
  protected:
  explicit Stream_Pair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:Stream.Pair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages1_2eproto;
};
// -------------------------------------------------------------------

class Stream final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Stream) */ {
 public:
  inline Stream() : Stream(nullptr) {}
  ~Stream() override;
  explicit PROTOBUF_CONSTEXPR Stream(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stream(const Stream& from);
  Stream(Stream&& from) noexcept
    : Stream() {
    *this = ::std::move(from);
  }

  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stream& operator=(Stream&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stream& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stream* internal_default_instance() {
    return reinterpret_cast<const Stream*>(
               &_Stream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Stream& a, Stream& b) {
    a.Swap(&b);
  }
  inline void Swap(Stream* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stream* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stream>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stream& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Stream& from) {
    Stream::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stream* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Stream";
  }
  protected:
  explicit Stream(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Stream_Pair Pair;

  typedef Stream_Type Type;
  static constexpr Type VIDEO =
    Stream_Type_VIDEO;
  static constexpr Type AUDIO =
    Stream_Type_AUDIO;
  static constexpr Type SUBTITLE =
    Stream_Type_SUBTITLE;
  static constexpr Type DATA =
    Stream_Type_DATA;
  static inline bool Type_IsValid(int value) {
    return Stream_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Stream_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Stream_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Stream_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Stream_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Stream_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Stream_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 14,
    kCodecFieldNumber = 3,
    kExtradataFieldNumber = 7,
    kNameFieldNumber = 10,
    kChannelFieldNumber = 11,
    kVideomtFieldNumber = 8,
    kAudiomtFieldNumber = 9,
    kSubtitlemtFieldNumber = 12,
    kDatamtFieldNumber = 13,
    kAvparamsFieldNumber = 15,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kBitrateFieldNumber = 4,
    kTbNumFieldNumber = 5,
    kTbDenFieldNumber = 6,
  };
  // repeated .Stream.Pair metadata = 14;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  ::Stream_Pair* mutable_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Stream_Pair >*
      mutable_metadata();
  private:
  const ::Stream_Pair& _internal_metadata(int index) const;
  ::Stream_Pair* _internal_add_metadata();
  public:
  const ::Stream_Pair& metadata(int index) const;
  ::Stream_Pair* add_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Stream_Pair >&
      metadata() const;

  // string codec = 3;
  void clear_codec();
  const std::string& codec() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_codec(ArgT0&& arg0, ArgT... args);
  std::string* mutable_codec();
  PROTOBUF_NODISCARD std::string* release_codec();
  void set_allocated_codec(std::string* codec);
  private:
  const std::string& _internal_codec() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codec(const std::string& value);
  std::string* _internal_mutable_codec();
  public:

  // bytes extradata = 7;
  void clear_extradata();
  const std::string& extradata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extradata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extradata();
  PROTOBUF_NODISCARD std::string* release_extradata();
  void set_allocated_extradata(std::string* extradata);
  private:
  const std::string& _internal_extradata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extradata(const std::string& value);
  std::string* _internal_mutable_extradata();
  public:

  // string name = 10;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string channel = 11;
  void clear_channel();
  const std::string& channel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_channel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_channel();
  PROTOBUF_NODISCARD std::string* release_channel();
  void set_allocated_channel(std::string* channel);
  private:
  const std::string& _internal_channel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel(const std::string& value);
  std::string* _internal_mutable_channel();
  public:

  // .VideoMediaType videomt = 8;
  bool has_videomt() const;
  private:
  bool _internal_has_videomt() const;
  public:
  void clear_videomt();
  const ::VideoMediaType& videomt() const;
  PROTOBUF_NODISCARD ::VideoMediaType* release_videomt();
  ::VideoMediaType* mutable_videomt();
  void set_allocated_videomt(::VideoMediaType* videomt);
  private:
  const ::VideoMediaType& _internal_videomt() const;
  ::VideoMediaType* _internal_mutable_videomt();
  public:
  void unsafe_arena_set_allocated_videomt(
      ::VideoMediaType* videomt);
  ::VideoMediaType* unsafe_arena_release_videomt();

  // .AudioMediaType audiomt = 9;
  bool has_audiomt() const;
  private:
  bool _internal_has_audiomt() const;
  public:
  void clear_audiomt();
  const ::AudioMediaType& audiomt() const;
  PROTOBUF_NODISCARD ::AudioMediaType* release_audiomt();
  ::AudioMediaType* mutable_audiomt();
  void set_allocated_audiomt(::AudioMediaType* audiomt);
  private:
  const ::AudioMediaType& _internal_audiomt() const;
  ::AudioMediaType* _internal_mutable_audiomt();
  public:
  void unsafe_arena_set_allocated_audiomt(
      ::AudioMediaType* audiomt);
  ::AudioMediaType* unsafe_arena_release_audiomt();

  // .SubtitleMediaType subtitlemt = 12;
  bool has_subtitlemt() const;
  private:
  bool _internal_has_subtitlemt() const;
  public:
  void clear_subtitlemt();
  const ::SubtitleMediaType& subtitlemt() const;
  PROTOBUF_NODISCARD ::SubtitleMediaType* release_subtitlemt();
  ::SubtitleMediaType* mutable_subtitlemt();
  void set_allocated_subtitlemt(::SubtitleMediaType* subtitlemt);
  private:
  const ::SubtitleMediaType& _internal_subtitlemt() const;
  ::SubtitleMediaType* _internal_mutable_subtitlemt();
  public:
  void unsafe_arena_set_allocated_subtitlemt(
      ::SubtitleMediaType* subtitlemt);
  ::SubtitleMediaType* unsafe_arena_release_subtitlemt();

  // .DataMediaType datamt = 13;
  bool has_datamt() const;
  private:
  bool _internal_has_datamt() const;
  public:
  void clear_datamt();
  const ::DataMediaType& datamt() const;
  PROTOBUF_NODISCARD ::DataMediaType* release_datamt();
  ::DataMediaType* mutable_datamt();
  void set_allocated_datamt(::DataMediaType* datamt);
  private:
  const ::DataMediaType& _internal_datamt() const;
  ::DataMediaType* _internal_mutable_datamt();
  public:
  void unsafe_arena_set_allocated_datamt(
      ::DataMediaType* datamt);
  ::DataMediaType* unsafe_arena_release_datamt();

  // .CodecParameters avparams = 15;
  bool has_avparams() const;
  private:
  bool _internal_has_avparams() const;
  public:
  void clear_avparams();
  const ::CodecParameters& avparams() const;
  PROTOBUF_NODISCARD ::CodecParameters* release_avparams();
  ::CodecParameters* mutable_avparams();
  void set_allocated_avparams(::CodecParameters* avparams);
  private:
  const ::CodecParameters& _internal_avparams() const;
  ::CodecParameters* _internal_mutable_avparams();
  public:
  void unsafe_arena_set_allocated_avparams(
      ::CodecParameters* avparams);
  ::CodecParameters* unsafe_arena_release_avparams();

  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // .Stream.Type type = 2;
  void clear_type();
  ::Stream_Type type() const;
  void set_type(::Stream_Type value);
  private:
  ::Stream_Type _internal_type() const;
  void _internal_set_type(::Stream_Type value);
  public:

  // uint32 bitrate = 4;
  void clear_bitrate();
  uint32_t bitrate() const;
  void set_bitrate(uint32_t value);
  private:
  uint32_t _internal_bitrate() const;
  void _internal_set_bitrate(uint32_t value);
  public:

  // uint32 tb_num = 5;
  void clear_tb_num();
  uint32_t tb_num() const;
  void set_tb_num(uint32_t value);
  private:
  uint32_t _internal_tb_num() const;
  void _internal_set_tb_num(uint32_t value);
  public:

  // uint32 tb_den = 6;
  void clear_tb_den();
  uint32_t tb_den() const;
  void set_tb_den(uint32_t value);
  private:
  uint32_t _internal_tb_den() const;
  void _internal_set_tb_den(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Stream)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Stream_Pair > metadata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr codec_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extradata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_;
    ::VideoMediaType* videomt_;
    ::AudioMediaType* audiomt_;
    ::SubtitleMediaType* subtitlemt_;
    ::DataMediaType* datamt_;
    ::CodecParameters* avparams_;
    uint32_t id_;
    int type_;
    uint32_t bitrate_;
    uint32_t tb_num_;
    uint32_t tb_den_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages1_2eproto;
};
// -------------------------------------------------------------------

class CodecParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CodecParameters) */ {
 public:
  inline CodecParameters() : CodecParameters(nullptr) {}
  ~CodecParameters() override;
  explicit PROTOBUF_CONSTEXPR CodecParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CodecParameters(const CodecParameters& from);
  CodecParameters(CodecParameters&& from) noexcept
    : CodecParameters() {
    *this = ::std::move(from);
  }

  inline CodecParameters& operator=(const CodecParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline CodecParameters& operator=(CodecParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CodecParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const CodecParameters* internal_default_instance() {
    return reinterpret_cast<const CodecParameters*>(
               &_CodecParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CodecParameters& a, CodecParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(CodecParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CodecParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CodecParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CodecParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CodecParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CodecParameters& from) {
    CodecParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CodecParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CodecParameters";
  }
  protected:
  explicit CodecParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtradataFieldNumber = 4,
    kCodecTypeFieldNumber = 1,
    kCodecIdFieldNumber = 2,
    kCodecTagFieldNumber = 3,
    kFormatFieldNumber = 5,
    kBitRateFieldNumber = 6,
    kBitsPerCodedSampleFieldNumber = 7,
    kBitsPerRawSampleFieldNumber = 8,
    kProfileFieldNumber = 9,
    kLevelFieldNumber = 10,
    kWidthFieldNumber = 11,
    kHeightFieldNumber = 12,
    kSampleAspectRatioNumFieldNumber = 13,
    kSampleAspectRatioDenFieldNumber = 14,
    kFieldOrderFieldNumber = 15,
    kColorRangeFieldNumber = 16,
    kColorPrimariesFieldNumber = 17,
    kColorTrcFieldNumber = 18,
    kColorSpaceFieldNumber = 19,
    kChromaLocationFieldNumber = 20,
    kChannelLayoutFieldNumber = 22,
    kVideoDelayFieldNumber = 21,
    kChannelsFieldNumber = 23,
    kSampleRateFieldNumber = 24,
    kBlockAlignFieldNumber = 25,
    kFrameSizeFieldNumber = 26,
    kInitialPaddingFieldNumber = 27,
    kTrailingPaddingFieldNumber = 28,
    kSeekPrerollFieldNumber = 29,
  };
  // bytes extradata = 4;
  void clear_extradata();
  const std::string& extradata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extradata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extradata();
  PROTOBUF_NODISCARD std::string* release_extradata();
  void set_allocated_extradata(std::string* extradata);
  private:
  const std::string& _internal_extradata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extradata(const std::string& value);
  std::string* _internal_mutable_extradata();
  public:

  // uint32 codec_type = 1;
  void clear_codec_type();
  uint32_t codec_type() const;
  void set_codec_type(uint32_t value);
  private:
  uint32_t _internal_codec_type() const;
  void _internal_set_codec_type(uint32_t value);
  public:

  // uint32 codec_id = 2;
  void clear_codec_id();
  uint32_t codec_id() const;
  void set_codec_id(uint32_t value);
  private:
  uint32_t _internal_codec_id() const;
  void _internal_set_codec_id(uint32_t value);
  public:

  // uint32 codec_tag = 3;
  void clear_codec_tag();
  uint32_t codec_tag() const;
  void set_codec_tag(uint32_t value);
  private:
  uint32_t _internal_codec_tag() const;
  void _internal_set_codec_tag(uint32_t value);
  public:

  // uint32 format = 5;
  void clear_format();
  uint32_t format() const;
  void set_format(uint32_t value);
  private:
  uint32_t _internal_format() const;
  void _internal_set_format(uint32_t value);
  public:

  // uint64 bit_rate = 6;
  void clear_bit_rate();
  uint64_t bit_rate() const;
  void set_bit_rate(uint64_t value);
  private:
  uint64_t _internal_bit_rate() const;
  void _internal_set_bit_rate(uint64_t value);
  public:

  // uint32 bits_per_coded_sample = 7;
  void clear_bits_per_coded_sample();
  uint32_t bits_per_coded_sample() const;
  void set_bits_per_coded_sample(uint32_t value);
  private:
  uint32_t _internal_bits_per_coded_sample() const;
  void _internal_set_bits_per_coded_sample(uint32_t value);
  public:

  // uint32 bits_per_raw_sample = 8;
  void clear_bits_per_raw_sample();
  uint32_t bits_per_raw_sample() const;
  void set_bits_per_raw_sample(uint32_t value);
  private:
  uint32_t _internal_bits_per_raw_sample() const;
  void _internal_set_bits_per_raw_sample(uint32_t value);
  public:

  // uint32 profile = 9;
  void clear_profile();
  uint32_t profile() const;
  void set_profile(uint32_t value);
  private:
  uint32_t _internal_profile() const;
  void _internal_set_profile(uint32_t value);
  public:

  // uint32 level = 10;
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // uint32 width = 11;
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // uint32 height = 12;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // int32 sample_aspect_ratio_num = 13;
  void clear_sample_aspect_ratio_num();
  int32_t sample_aspect_ratio_num() const;
  void set_sample_aspect_ratio_num(int32_t value);
  private:
  int32_t _internal_sample_aspect_ratio_num() const;
  void _internal_set_sample_aspect_ratio_num(int32_t value);
  public:

  // int32 sample_aspect_ratio_den = 14;
  void clear_sample_aspect_ratio_den();
  int32_t sample_aspect_ratio_den() const;
  void set_sample_aspect_ratio_den(int32_t value);
  private:
  int32_t _internal_sample_aspect_ratio_den() const;
  void _internal_set_sample_aspect_ratio_den(int32_t value);
  public:

  // uint32 field_order = 15;
  void clear_field_order();
  uint32_t field_order() const;
  void set_field_order(uint32_t value);
  private:
  uint32_t _internal_field_order() const;
  void _internal_set_field_order(uint32_t value);
  public:

  // uint32 color_range = 16;
  void clear_color_range();
  uint32_t color_range() const;
  void set_color_range(uint32_t value);
  private:
  uint32_t _internal_color_range() const;
  void _internal_set_color_range(uint32_t value);
  public:

  // uint32 color_primaries = 17;
  void clear_color_primaries();
  uint32_t color_primaries() const;
  void set_color_primaries(uint32_t value);
  private:
  uint32_t _internal_color_primaries() const;
  void _internal_set_color_primaries(uint32_t value);
  public:

  // uint32 color_trc = 18;
  void clear_color_trc();
  uint32_t color_trc() const;
  void set_color_trc(uint32_t value);
  private:
  uint32_t _internal_color_trc() const;
  void _internal_set_color_trc(uint32_t value);
  public:

  // uint32 color_space = 19;
  void clear_color_space();
  uint32_t color_space() const;
  void set_color_space(uint32_t value);
  private:
  uint32_t _internal_color_space() const;
  void _internal_set_color_space(uint32_t value);
  public:

  // uint32 chroma_location = 20;
  void clear_chroma_location();
  uint32_t chroma_location() const;
  void set_chroma_location(uint32_t value);
  private:
  uint32_t _internal_chroma_location() const;
  void _internal_set_chroma_location(uint32_t value);
  public:

  // uint64 channel_layout = 22;
  void clear_channel_layout();
  uint64_t channel_layout() const;
  void set_channel_layout(uint64_t value);
  private:
  uint64_t _internal_channel_layout() const;
  void _internal_set_channel_layout(uint64_t value);
  public:

  // uint32 video_delay = 21;
  void clear_video_delay();
  uint32_t video_delay() const;
  void set_video_delay(uint32_t value);
  private:
  uint32_t _internal_video_delay() const;
  void _internal_set_video_delay(uint32_t value);
  public:

  // uint32 channels = 23;
  void clear_channels();
  uint32_t channels() const;
  void set_channels(uint32_t value);
  private:
  uint32_t _internal_channels() const;
  void _internal_set_channels(uint32_t value);
  public:

  // uint32 sample_rate = 24;
  void clear_sample_rate();
  uint32_t sample_rate() const;
  void set_sample_rate(uint32_t value);
  private:
  uint32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(uint32_t value);
  public:

  // uint32 block_align = 25;
  void clear_block_align();
  uint32_t block_align() const;
  void set_block_align(uint32_t value);
  private:
  uint32_t _internal_block_align() const;
  void _internal_set_block_align(uint32_t value);
  public:

  // uint32 frame_size = 26;
  void clear_frame_size();
  uint32_t frame_size() const;
  void set_frame_size(uint32_t value);
  private:
  uint32_t _internal_frame_size() const;
  void _internal_set_frame_size(uint32_t value);
  public:

  // uint32 initial_padding = 27;
  void clear_initial_padding();
  uint32_t initial_padding() const;
  void set_initial_padding(uint32_t value);
  private:
  uint32_t _internal_initial_padding() const;
  void _internal_set_initial_padding(uint32_t value);
  public:

  // uint32 trailing_padding = 28;
  void clear_trailing_padding();
  uint32_t trailing_padding() const;
  void set_trailing_padding(uint32_t value);
  private:
  uint32_t _internal_trailing_padding() const;
  void _internal_set_trailing_padding(uint32_t value);
  public:

  // uint32 seek_preroll = 29;
  void clear_seek_preroll();
  uint32_t seek_preroll() const;
  void set_seek_preroll(uint32_t value);
  private:
  uint32_t _internal_seek_preroll() const;
  void _internal_set_seek_preroll(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CodecParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extradata_;
    uint32_t codec_type_;
    uint32_t codec_id_;
    uint32_t codec_tag_;
    uint32_t format_;
    uint64_t bit_rate_;
    uint32_t bits_per_coded_sample_;
    uint32_t bits_per_raw_sample_;
    uint32_t profile_;
    uint32_t level_;
    uint32_t width_;
    uint32_t height_;
    int32_t sample_aspect_ratio_num_;
    int32_t sample_aspect_ratio_den_;
    uint32_t field_order_;
    uint32_t color_range_;
    uint32_t color_primaries_;
    uint32_t color_trc_;
    uint32_t color_space_;
    uint32_t chroma_location_;
    uint64_t channel_layout_;
    uint32_t video_delay_;
    uint32_t channels_;
    uint32_t sample_rate_;
    uint32_t block_align_;
    uint32_t frame_size_;
    uint32_t initial_padding_;
    uint32_t trailing_padding_;
    uint32_t seek_preroll_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages1_2eproto;
};
// -------------------------------------------------------------------

class MediaPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MediaPacket) */ {
 public:
  inline MediaPacket() : MediaPacket(nullptr) {}
  ~MediaPacket() override;
  explicit PROTOBUF_CONSTEXPR MediaPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MediaPacket(const MediaPacket& from);
  MediaPacket(MediaPacket&& from) noexcept
    : MediaPacket() {
    *this = ::std::move(from);
  }

  inline MediaPacket& operator=(const MediaPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaPacket& operator=(MediaPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaPacket* internal_default_instance() {
    return reinterpret_cast<const MediaPacket*>(
               &_MediaPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MediaPacket& a, MediaPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MediaPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MediaPacket& from) {
    MediaPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MediaPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MediaPacket";
  }
  protected:
  explicit MediaPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 5,
    kDtsFieldNumber = 2,
    kStreamIdFieldNumber = 1,
    kPtsOffsetFieldNumber = 3,
    kFrametypeFieldNumber = 4,
    kDurationFieldNumber = 6,
  };
  // bytes data = 5;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint64 dts = 2;
  void clear_dts();
  uint64_t dts() const;
  void set_dts(uint64_t value);
  private:
  uint64_t _internal_dts() const;
  void _internal_set_dts(uint64_t value);
  public:

  // uint32 stream_id = 1;
  void clear_stream_id();
  uint32_t stream_id() const;
  void set_stream_id(uint32_t value);
  private:
  uint32_t _internal_stream_id() const;
  void _internal_set_stream_id(uint32_t value);
  public:

  // uint32 pts_offset = 3;
  void clear_pts_offset();
  uint32_t pts_offset() const;
  void set_pts_offset(uint32_t value);
  private:
  uint32_t _internal_pts_offset() const;
  void _internal_set_pts_offset(uint32_t value);
  public:

  // .FrameType frametype = 4;
  void clear_frametype();
  ::FrameType frametype() const;
  void set_frametype(::FrameType value);
  private:
  ::FrameType _internal_frametype() const;
  void _internal_set_frametype(::FrameType value);
  public:

  // uint32 duration = 6;
  void clear_duration();
  uint32_t duration() const;
  void set_duration(uint32_t value);
  private:
  uint32_t _internal_duration() const;
  void _internal_set_duration(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MediaPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    uint64_t dts_;
    uint32_t stream_id_;
    uint32_t pts_offset_;
    int frametype_;
    uint32_t duration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages1_2eproto;
};
// -------------------------------------------------------------------

class Start final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Start) */ {
 public:
  inline Start() : Start(nullptr) {}
  ~Start() override;
  explicit PROTOBUF_CONSTEXPR Start(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Start(const Start& from);
  Start(Start&& from) noexcept
    : Start() {
    *this = ::std::move(from);
  }

  inline Start& operator=(const Start& from) {
    CopyFrom(from);
    return *this;
  }
  inline Start& operator=(Start&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Start& default_instance() {
    return *internal_default_instance();
  }
  static inline const Start* internal_default_instance() {
    return reinterpret_cast<const Start*>(
               &_Start_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Start& a, Start& b) {
    a.Swap(&b);
  }
  inline void Swap(Start* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Start* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Start* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Start>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Start& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Start& from) {
    Start::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Start* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Start";
  }
  protected:
  explicit Start(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelFieldNumber = 4,
    kStartTsFieldNumber = 1,
    kTbNumFieldNumber = 2,
    kTbDenFieldNumber = 3,
  };
  // string channel = 4;
  void clear_channel();
  const std::string& channel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_channel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_channel();
  PROTOBUF_NODISCARD std::string* release_channel();
  void set_allocated_channel(std::string* channel);
  private:
  const std::string& _internal_channel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel(const std::string& value);
  std::string* _internal_mutable_channel();
  public:

  // uint64 start_ts = 1;
  void clear_start_ts();
  uint64_t start_ts() const;
  void set_start_ts(uint64_t value);
  private:
  uint64_t _internal_start_ts() const;
  void _internal_set_start_ts(uint64_t value);
  public:

  // uint32 tb_num = 2;
  void clear_tb_num();
  uint32_t tb_num() const;
  void set_tb_num(uint32_t value);
  private:
  uint32_t _internal_tb_num() const;
  void _internal_set_tb_num(uint32_t value);
  public:

  // uint32 tb_den = 3;
  void clear_tb_den();
  uint32_t tb_den() const;
  void set_tb_den(uint32_t value);
  private:
  uint32_t _internal_tb_den() const;
  void _internal_set_tb_den(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Start)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_;
    uint64_t start_ts_;
    uint32_t tb_num_;
    uint32_t tb_den_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages1_2eproto;
};
// -------------------------------------------------------------------

class Stop final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Stop) */ {
 public:
  inline Stop() : Stop(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Stop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stop(const Stop& from);
  Stop(Stop&& from) noexcept
    : Stop() {
    *this = ::std::move(from);
  }

  inline Stop& operator=(const Stop& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stop& operator=(Stop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stop& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stop* internal_default_instance() {
    return reinterpret_cast<const Stop*>(
               &_Stop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Stop& a, Stop& b) {
    a.Swap(&b);
  }
  inline void Swap(Stop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Stop& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Stop& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Stop";
  }
  protected:
  explicit Stop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Stop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages1_2eproto;
};
// -------------------------------------------------------------------

class GopSlice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GopSlice) */ {
 public:
  inline GopSlice() : GopSlice(nullptr) {}
  ~GopSlice() override;
  explicit PROTOBUF_CONSTEXPR GopSlice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GopSlice(const GopSlice& from);
  GopSlice(GopSlice&& from) noexcept
    : GopSlice() {
    *this = ::std::move(from);
  }

  inline GopSlice& operator=(const GopSlice& from) {
    CopyFrom(from);
    return *this;
  }
  inline GopSlice& operator=(GopSlice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GopSlice& default_instance() {
    return *internal_default_instance();
  }
  static inline const GopSlice* internal_default_instance() {
    return reinterpret_cast<const GopSlice*>(
               &_GopSlice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GopSlice& a, GopSlice& b) {
    a.Swap(&b);
  }
  inline void Swap(GopSlice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GopSlice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GopSlice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GopSlice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GopSlice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GopSlice& from) {
    GopSlice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GopSlice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GopSlice";
  }
  protected:
  explicit GopSlice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketsFieldNumber = 5,
    kTsNumFieldNumber = 1,
    kTsDenFieldNumber = 2,
    kDurationNumFieldNumber = 3,
    kDurationDenFieldNumber = 4,
  };
  // repeated .MediaPacket packets = 5;
  int packets_size() const;
  private:
  int _internal_packets_size() const;
  public:
  void clear_packets();
  ::MediaPacket* mutable_packets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MediaPacket >*
      mutable_packets();
  private:
  const ::MediaPacket& _internal_packets(int index) const;
  ::MediaPacket* _internal_add_packets();
  public:
  const ::MediaPacket& packets(int index) const;
  ::MediaPacket* add_packets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MediaPacket >&
      packets() const;

  // int64 ts_num = 1;
  void clear_ts_num();
  int64_t ts_num() const;
  void set_ts_num(int64_t value);
  private:
  int64_t _internal_ts_num() const;
  void _internal_set_ts_num(int64_t value);
  public:

  // int64 ts_den = 2;
  void clear_ts_den();
  int64_t ts_den() const;
  void set_ts_den(int64_t value);
  private:
  int64_t _internal_ts_den() const;
  void _internal_set_ts_den(int64_t value);
  public:

  // int64 duration_num = 3;
  void clear_duration_num();
  int64_t duration_num() const;
  void set_duration_num(int64_t value);
  private:
  int64_t _internal_duration_num() const;
  void _internal_set_duration_num(int64_t value);
  public:

  // int64 duration_den = 4;
  void clear_duration_den();
  int64_t duration_den() const;
  void set_duration_den(int64_t value);
  private:
  int64_t _internal_duration_den() const;
  void _internal_set_duration_den(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:GopSlice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MediaPacket > packets_;
    int64_t ts_num_;
    int64_t ts_den_;
    int64_t duration_num_;
    int64_t duration_den_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages1_2eproto;
};
// -------------------------------------------------------------------

class Msg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Msg) */ {
 public:
  inline Msg() : Msg(nullptr) {}
  ~Msg() override;
  explicit PROTOBUF_CONSTEXPR Msg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Msg(const Msg& from);
  Msg(Msg&& from) noexcept
    : Msg() {
    *this = ::std::move(from);
  }

  inline Msg& operator=(const Msg& from) {
    CopyFrom(from);
    return *this;
  }
  inline Msg& operator=(Msg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Msg& default_instance() {
    return *internal_default_instance();
  }
  static inline const Msg* internal_default_instance() {
    return reinterpret_cast<const Msg*>(
               &_Msg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Msg& a, Msg& b) {
    a.Swap(&b);
  }
  inline void Swap(Msg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Msg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Msg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Msg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Msg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Msg& from) {
    Msg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Msg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Msg";
  }
  protected:
  explicit Msg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Msg_Type Type;
  static constexpr Type Nop =
    Msg_Type_Nop;
  static constexpr Type Start =
    Msg_Type_Start;
  static constexpr Type Stop =
    Msg_Type_Stop;
  static constexpr Type Stream =
    Msg_Type_Stream;
  static constexpr Type MediaPacket =
    Msg_Type_MediaPacket;
  static constexpr Type GopSlice =
    Msg_Type_GopSlice;
  static inline bool Type_IsValid(int value) {
    return Msg_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Msg_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Msg_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Msg_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Msg_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Msg_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Msg_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStopFieldNumber = 2,
    kStartFieldNumber = 3,
    kStreamFieldNumber = 4,
    kMediapacketFieldNumber = 5,
    kGopsliceFieldNumber = 6,
    kTypeFieldNumber = 1,
  };
  // .Stop stop = 2;
  bool has_stop() const;
  private:
  bool _internal_has_stop() const;
  public:
  void clear_stop();
  const ::Stop& stop() const;
  PROTOBUF_NODISCARD ::Stop* release_stop();
  ::Stop* mutable_stop();
  void set_allocated_stop(::Stop* stop);
  private:
  const ::Stop& _internal_stop() const;
  ::Stop* _internal_mutable_stop();
  public:
  void unsafe_arena_set_allocated_stop(
      ::Stop* stop);
  ::Stop* unsafe_arena_release_stop();

  // .Start start = 3;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::Start& start() const;
  PROTOBUF_NODISCARD ::Start* release_start();
  ::Start* mutable_start();
  void set_allocated_start(::Start* start);
  private:
  const ::Start& _internal_start() const;
  ::Start* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::Start* start);
  ::Start* unsafe_arena_release_start();

  // .Stream stream = 4;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::Stream& stream() const;
  PROTOBUF_NODISCARD ::Stream* release_stream();
  ::Stream* mutable_stream();
  void set_allocated_stream(::Stream* stream);
  private:
  const ::Stream& _internal_stream() const;
  ::Stream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::Stream* stream);
  ::Stream* unsafe_arena_release_stream();

  // .MediaPacket mediapacket = 5;
  bool has_mediapacket() const;
  private:
  bool _internal_has_mediapacket() const;
  public:
  void clear_mediapacket();
  const ::MediaPacket& mediapacket() const;
  PROTOBUF_NODISCARD ::MediaPacket* release_mediapacket();
  ::MediaPacket* mutable_mediapacket();
  void set_allocated_mediapacket(::MediaPacket* mediapacket);
  private:
  const ::MediaPacket& _internal_mediapacket() const;
  ::MediaPacket* _internal_mutable_mediapacket();
  public:
  void unsafe_arena_set_allocated_mediapacket(
      ::MediaPacket* mediapacket);
  ::MediaPacket* unsafe_arena_release_mediapacket();

  // .GopSlice gopslice = 6;
  bool has_gopslice() const;
  private:
  bool _internal_has_gopslice() const;
  public:
  void clear_gopslice();
  const ::GopSlice& gopslice() const;
  PROTOBUF_NODISCARD ::GopSlice* release_gopslice();
  ::GopSlice* mutable_gopslice();
  void set_allocated_gopslice(::GopSlice* gopslice);
  private:
  const ::GopSlice& _internal_gopslice() const;
  ::GopSlice* _internal_mutable_gopslice();
  public:
  void unsafe_arena_set_allocated_gopslice(
      ::GopSlice* gopslice);
  ::GopSlice* unsafe_arena_release_gopslice();

  // .Msg.Type type = 1;
  void clear_type();
  ::Msg_Type type() const;
  void set_type(::Msg_Type value);
  private:
  ::Msg_Type _internal_type() const;
  void _internal_set_type(::Msg_Type value);
  public:

  // @@protoc_insertion_point(class_scope:Msg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Stop* stop_;
    ::Start* start_;
    ::Stream* stream_;
    ::MediaPacket* mediapacket_;
    ::GopSlice* gopslice_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages1_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VideoMediaType

// uint32 width = 4;
inline void VideoMediaType::clear_width() {
  _impl_.width_ = 0u;
}
inline uint32_t VideoMediaType::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t VideoMediaType::width() const {
  // @@protoc_insertion_point(field_get:VideoMediaType.width)
  return _internal_width();
}
inline void VideoMediaType::_internal_set_width(uint32_t value) {
  
  _impl_.width_ = value;
}
inline void VideoMediaType::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:VideoMediaType.width)
}

// uint32 height = 5;
inline void VideoMediaType::clear_height() {
  _impl_.height_ = 0u;
}
inline uint32_t VideoMediaType::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t VideoMediaType::height() const {
  // @@protoc_insertion_point(field_get:VideoMediaType.height)
  return _internal_height();
}
inline void VideoMediaType::_internal_set_height(uint32_t value) {
  
  _impl_.height_ = value;
}
inline void VideoMediaType::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:VideoMediaType.height)
}

// uint32 fps_num = 6;
inline void VideoMediaType::clear_fps_num() {
  _impl_.fps_num_ = 0u;
}
inline uint32_t VideoMediaType::_internal_fps_num() const {
  return _impl_.fps_num_;
}
inline uint32_t VideoMediaType::fps_num() const {
  // @@protoc_insertion_point(field_get:VideoMediaType.fps_num)
  return _internal_fps_num();
}
inline void VideoMediaType::_internal_set_fps_num(uint32_t value) {
  
  _impl_.fps_num_ = value;
}
inline void VideoMediaType::set_fps_num(uint32_t value) {
  _internal_set_fps_num(value);
  // @@protoc_insertion_point(field_set:VideoMediaType.fps_num)
}

// uint32 fps_den = 7;
inline void VideoMediaType::clear_fps_den() {
  _impl_.fps_den_ = 0u;
}
inline uint32_t VideoMediaType::_internal_fps_den() const {
  return _impl_.fps_den_;
}
inline uint32_t VideoMediaType::fps_den() const {
  // @@protoc_insertion_point(field_get:VideoMediaType.fps_den)
  return _internal_fps_den();
}
inline void VideoMediaType::_internal_set_fps_den(uint32_t value) {
  
  _impl_.fps_den_ = value;
}
inline void VideoMediaType::set_fps_den(uint32_t value) {
  _internal_set_fps_den(value);
  // @@protoc_insertion_point(field_set:VideoMediaType.fps_den)
}

// uint32 aspect_num = 8;
inline void VideoMediaType::clear_aspect_num() {
  _impl_.aspect_num_ = 0u;
}
inline uint32_t VideoMediaType::_internal_aspect_num() const {
  return _impl_.aspect_num_;
}
inline uint32_t VideoMediaType::aspect_num() const {
  // @@protoc_insertion_point(field_get:VideoMediaType.aspect_num)
  return _internal_aspect_num();
}
inline void VideoMediaType::_internal_set_aspect_num(uint32_t value) {
  
  _impl_.aspect_num_ = value;
}
inline void VideoMediaType::set_aspect_num(uint32_t value) {
  _internal_set_aspect_num(value);
  // @@protoc_insertion_point(field_set:VideoMediaType.aspect_num)
}

// uint32 aspect_den = 9;
inline void VideoMediaType::clear_aspect_den() {
  _impl_.aspect_den_ = 0u;
}
inline uint32_t VideoMediaType::_internal_aspect_den() const {
  return _impl_.aspect_den_;
}
inline uint32_t VideoMediaType::aspect_den() const {
  // @@protoc_insertion_point(field_get:VideoMediaType.aspect_den)
  return _internal_aspect_den();
}
inline void VideoMediaType::_internal_set_aspect_den(uint32_t value) {
  
  _impl_.aspect_den_ = value;
}
inline void VideoMediaType::set_aspect_den(uint32_t value) {
  _internal_set_aspect_den(value);
  // @@protoc_insertion_point(field_set:VideoMediaType.aspect_den)
}

// .PixFmt pix_fmt = 10;
inline void VideoMediaType::clear_pix_fmt() {
  _impl_.pix_fmt_ = 0;
}
inline ::PixFmt VideoMediaType::_internal_pix_fmt() const {
  return static_cast< ::PixFmt >(_impl_.pix_fmt_);
}
inline ::PixFmt VideoMediaType::pix_fmt() const {
  // @@protoc_insertion_point(field_get:VideoMediaType.pix_fmt)
  return _internal_pix_fmt();
}
inline void VideoMediaType::_internal_set_pix_fmt(::PixFmt value) {
  
  _impl_.pix_fmt_ = value;
}
inline void VideoMediaType::set_pix_fmt(::PixFmt value) {
  _internal_set_pix_fmt(value);
  // @@protoc_insertion_point(field_set:VideoMediaType.pix_fmt)
}

// -------------------------------------------------------------------

// SubtitleMediaType_Pair

// string key = 1;
inline void SubtitleMediaType_Pair::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& SubtitleMediaType_Pair::key() const {
  // @@protoc_insertion_point(field_get:SubtitleMediaType.Pair.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubtitleMediaType_Pair::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SubtitleMediaType.Pair.key)
}
inline std::string* SubtitleMediaType_Pair::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:SubtitleMediaType.Pair.key)
  return _s;
}
inline const std::string& SubtitleMediaType_Pair::_internal_key() const {
  return _impl_.key_.Get();
}
inline void SubtitleMediaType_Pair::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* SubtitleMediaType_Pair::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* SubtitleMediaType_Pair::release_key() {
  // @@protoc_insertion_point(field_release:SubtitleMediaType.Pair.key)
  return _impl_.key_.Release();
}
inline void SubtitleMediaType_Pair::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SubtitleMediaType.Pair.key)
}

// string value = 2;
inline void SubtitleMediaType_Pair::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& SubtitleMediaType_Pair::value() const {
  // @@protoc_insertion_point(field_get:SubtitleMediaType.Pair.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubtitleMediaType_Pair::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SubtitleMediaType.Pair.value)
}
inline std::string* SubtitleMediaType_Pair::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:SubtitleMediaType.Pair.value)
  return _s;
}
inline const std::string& SubtitleMediaType_Pair::_internal_value() const {
  return _impl_.value_.Get();
}
inline void SubtitleMediaType_Pair::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* SubtitleMediaType_Pair::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* SubtitleMediaType_Pair::release_value() {
  // @@protoc_insertion_point(field_release:SubtitleMediaType.Pair.value)
  return _impl_.value_.Release();
}
inline void SubtitleMediaType_Pair::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SubtitleMediaType.Pair.value)
}

// -------------------------------------------------------------------

// SubtitleMediaType

// uint32 aspect_num = 1;
inline void SubtitleMediaType::clear_aspect_num() {
  _impl_.aspect_num_ = 0u;
}
inline uint32_t SubtitleMediaType::_internal_aspect_num() const {
  return _impl_.aspect_num_;
}
inline uint32_t SubtitleMediaType::aspect_num() const {
  // @@protoc_insertion_point(field_get:SubtitleMediaType.aspect_num)
  return _internal_aspect_num();
}
inline void SubtitleMediaType::_internal_set_aspect_num(uint32_t value) {
  
  _impl_.aspect_num_ = value;
}
inline void SubtitleMediaType::set_aspect_num(uint32_t value) {
  _internal_set_aspect_num(value);
  // @@protoc_insertion_point(field_set:SubtitleMediaType.aspect_num)
}

// uint32 aspect_den = 2;
inline void SubtitleMediaType::clear_aspect_den() {
  _impl_.aspect_den_ = 0u;
}
inline uint32_t SubtitleMediaType::_internal_aspect_den() const {
  return _impl_.aspect_den_;
}
inline uint32_t SubtitleMediaType::aspect_den() const {
  // @@protoc_insertion_point(field_get:SubtitleMediaType.aspect_den)
  return _internal_aspect_den();
}
inline void SubtitleMediaType::_internal_set_aspect_den(uint32_t value) {
  
  _impl_.aspect_den_ = value;
}
inline void SubtitleMediaType::set_aspect_den(uint32_t value) {
  _internal_set_aspect_den(value);
  // @@protoc_insertion_point(field_set:SubtitleMediaType.aspect_den)
}

// repeated .SubtitleMediaType.Pair metadata = 3;
inline int SubtitleMediaType::_internal_metadata_size() const {
  return _impl_.metadata_.size();
}
inline int SubtitleMediaType::metadata_size() const {
  return _internal_metadata_size();
}
inline void SubtitleMediaType::clear_metadata() {
  _impl_.metadata_.Clear();
}
inline ::SubtitleMediaType_Pair* SubtitleMediaType::mutable_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:SubtitleMediaType.metadata)
  return _impl_.metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SubtitleMediaType_Pair >*
SubtitleMediaType::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:SubtitleMediaType.metadata)
  return &_impl_.metadata_;
}
inline const ::SubtitleMediaType_Pair& SubtitleMediaType::_internal_metadata(int index) const {
  return _impl_.metadata_.Get(index);
}
inline const ::SubtitleMediaType_Pair& SubtitleMediaType::metadata(int index) const {
  // @@protoc_insertion_point(field_get:SubtitleMediaType.metadata)
  return _internal_metadata(index);
}
inline ::SubtitleMediaType_Pair* SubtitleMediaType::_internal_add_metadata() {
  return _impl_.metadata_.Add();
}
inline ::SubtitleMediaType_Pair* SubtitleMediaType::add_metadata() {
  ::SubtitleMediaType_Pair* _add = _internal_add_metadata();
  // @@protoc_insertion_point(field_add:SubtitleMediaType.metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SubtitleMediaType_Pair >&
SubtitleMediaType::metadata() const {
  // @@protoc_insertion_point(field_list:SubtitleMediaType.metadata)
  return _impl_.metadata_;
}

// bytes header = 4;
inline void SubtitleMediaType::clear_header() {
  _impl_.header_.ClearToEmpty();
}
inline const std::string& SubtitleMediaType::header() const {
  // @@protoc_insertion_point(field_get:SubtitleMediaType.header)
  return _internal_header();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubtitleMediaType::set_header(ArgT0&& arg0, ArgT... args) {
 
 _impl_.header_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SubtitleMediaType.header)
}
inline std::string* SubtitleMediaType::mutable_header() {
  std::string* _s = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:SubtitleMediaType.header)
  return _s;
}
inline const std::string& SubtitleMediaType::_internal_header() const {
  return _impl_.header_.Get();
}
inline void SubtitleMediaType::_internal_set_header(const std::string& value) {
  
  _impl_.header_.Set(value, GetArenaForAllocation());
}
inline std::string* SubtitleMediaType::_internal_mutable_header() {
  
  return _impl_.header_.Mutable(GetArenaForAllocation());
}
inline std::string* SubtitleMediaType::release_header() {
  // @@protoc_insertion_point(field_release:SubtitleMediaType.header)
  return _impl_.header_.Release();
}
inline void SubtitleMediaType::set_allocated_header(std::string* header) {
  if (header != nullptr) {
    
  } else {
    
  }
  _impl_.header_.SetAllocated(header, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.header_.IsDefault()) {
    _impl_.header_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SubtitleMediaType.header)
}

// uint32 width = 5;
inline void SubtitleMediaType::clear_width() {
  _impl_.width_ = 0u;
}
inline uint32_t SubtitleMediaType::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t SubtitleMediaType::width() const {
  // @@protoc_insertion_point(field_get:SubtitleMediaType.width)
  return _internal_width();
}
inline void SubtitleMediaType::_internal_set_width(uint32_t value) {
  
  _impl_.width_ = value;
}
inline void SubtitleMediaType::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:SubtitleMediaType.width)
}

// uint32 height = 6;
inline void SubtitleMediaType::clear_height() {
  _impl_.height_ = 0u;
}
inline uint32_t SubtitleMediaType::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t SubtitleMediaType::height() const {
  // @@protoc_insertion_point(field_get:SubtitleMediaType.height)
  return _internal_height();
}
inline void SubtitleMediaType::_internal_set_height(uint32_t value) {
  
  _impl_.height_ = value;
}
inline void SubtitleMediaType::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:SubtitleMediaType.height)
}

// -------------------------------------------------------------------

// DataMediaType_Pair

// string key = 1;
inline void DataMediaType_Pair::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& DataMediaType_Pair::key() const {
  // @@protoc_insertion_point(field_get:DataMediaType.Pair.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMediaType_Pair::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DataMediaType.Pair.key)
}
inline std::string* DataMediaType_Pair::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:DataMediaType.Pair.key)
  return _s;
}
inline const std::string& DataMediaType_Pair::_internal_key() const {
  return _impl_.key_.Get();
}
inline void DataMediaType_Pair::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMediaType_Pair::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMediaType_Pair::release_key() {
  // @@protoc_insertion_point(field_release:DataMediaType.Pair.key)
  return _impl_.key_.Release();
}
inline void DataMediaType_Pair::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DataMediaType.Pair.key)
}

// string value = 2;
inline void DataMediaType_Pair::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& DataMediaType_Pair::value() const {
  // @@protoc_insertion_point(field_get:DataMediaType.Pair.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMediaType_Pair::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DataMediaType.Pair.value)
}
inline std::string* DataMediaType_Pair::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:DataMediaType.Pair.value)
  return _s;
}
inline const std::string& DataMediaType_Pair::_internal_value() const {
  return _impl_.value_.Get();
}
inline void DataMediaType_Pair::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMediaType_Pair::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMediaType_Pair::release_value() {
  // @@protoc_insertion_point(field_release:DataMediaType.Pair.value)
  return _impl_.value_.Release();
}
inline void DataMediaType_Pair::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DataMediaType.Pair.value)
}

// -------------------------------------------------------------------

// DataMediaType

// repeated .DataMediaType.Pair info = 1;
inline int DataMediaType::_internal_info_size() const {
  return _impl_.info_.size();
}
inline int DataMediaType::info_size() const {
  return _internal_info_size();
}
inline void DataMediaType::clear_info() {
  _impl_.info_.Clear();
}
inline ::DataMediaType_Pair* DataMediaType::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:DataMediaType.info)
  return _impl_.info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataMediaType_Pair >*
DataMediaType::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:DataMediaType.info)
  return &_impl_.info_;
}
inline const ::DataMediaType_Pair& DataMediaType::_internal_info(int index) const {
  return _impl_.info_.Get(index);
}
inline const ::DataMediaType_Pair& DataMediaType::info(int index) const {
  // @@protoc_insertion_point(field_get:DataMediaType.info)
  return _internal_info(index);
}
inline ::DataMediaType_Pair* DataMediaType::_internal_add_info() {
  return _impl_.info_.Add();
}
inline ::DataMediaType_Pair* DataMediaType::add_info() {
  ::DataMediaType_Pair* _add = _internal_add_info();
  // @@protoc_insertion_point(field_add:DataMediaType.info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataMediaType_Pair >&
DataMediaType::info() const {
  // @@protoc_insertion_point(field_list:DataMediaType.info)
  return _impl_.info_;
}

// -------------------------------------------------------------------

// AudioMediaType

// uint32 freq = 4;
inline void AudioMediaType::clear_freq() {
  _impl_.freq_ = 0u;
}
inline uint32_t AudioMediaType::_internal_freq() const {
  return _impl_.freq_;
}
inline uint32_t AudioMediaType::freq() const {
  // @@protoc_insertion_point(field_get:AudioMediaType.freq)
  return _internal_freq();
}
inline void AudioMediaType::_internal_set_freq(uint32_t value) {
  
  _impl_.freq_ = value;
}
inline void AudioMediaType::set_freq(uint32_t value) {
  _internal_set_freq(value);
  // @@protoc_insertion_point(field_set:AudioMediaType.freq)
}

// uint32 nchan = 5;
inline void AudioMediaType::clear_nchan() {
  _impl_.nchan_ = 0u;
}
inline uint32_t AudioMediaType::_internal_nchan() const {
  return _impl_.nchan_;
}
inline uint32_t AudioMediaType::nchan() const {
  // @@protoc_insertion_point(field_get:AudioMediaType.nchan)
  return _internal_nchan();
}
inline void AudioMediaType::_internal_set_nchan(uint32_t value) {
  
  _impl_.nchan_ = value;
}
inline void AudioMediaType::set_nchan(uint32_t value) {
  _internal_set_nchan(value);
  // @@protoc_insertion_point(field_set:AudioMediaType.nchan)
}

// uint32 ssize = 6;
inline void AudioMediaType::clear_ssize() {
  _impl_.ssize_ = 0u;
}
inline uint32_t AudioMediaType::_internal_ssize() const {
  return _impl_.ssize_;
}
inline uint32_t AudioMediaType::ssize() const {
  // @@protoc_insertion_point(field_get:AudioMediaType.ssize)
  return _internal_ssize();
}
inline void AudioMediaType::_internal_set_ssize(uint32_t value) {
  
  _impl_.ssize_ = value;
}
inline void AudioMediaType::set_ssize(uint32_t value) {
  _internal_set_ssize(value);
  // @@protoc_insertion_point(field_set:AudioMediaType.ssize)
}

// .AudioMediaType.SampleFmt sample_fmt = 7;
inline void AudioMediaType::clear_sample_fmt() {
  _impl_.sample_fmt_ = 0;
}
inline ::AudioMediaType_SampleFmt AudioMediaType::_internal_sample_fmt() const {
  return static_cast< ::AudioMediaType_SampleFmt >(_impl_.sample_fmt_);
}
inline ::AudioMediaType_SampleFmt AudioMediaType::sample_fmt() const {
  // @@protoc_insertion_point(field_get:AudioMediaType.sample_fmt)
  return _internal_sample_fmt();
}
inline void AudioMediaType::_internal_set_sample_fmt(::AudioMediaType_SampleFmt value) {
  
  _impl_.sample_fmt_ = value;
}
inline void AudioMediaType::set_sample_fmt(::AudioMediaType_SampleFmt value) {
  _internal_set_sample_fmt(value);
  // @@protoc_insertion_point(field_set:AudioMediaType.sample_fmt)
}

// string layout = 8;
inline void AudioMediaType::clear_layout() {
  _impl_.layout_.ClearToEmpty();
}
inline const std::string& AudioMediaType::layout() const {
  // @@protoc_insertion_point(field_get:AudioMediaType.layout)
  return _internal_layout();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioMediaType::set_layout(ArgT0&& arg0, ArgT... args) {
 
 _impl_.layout_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AudioMediaType.layout)
}
inline std::string* AudioMediaType::mutable_layout() {
  std::string* _s = _internal_mutable_layout();
  // @@protoc_insertion_point(field_mutable:AudioMediaType.layout)
  return _s;
}
inline const std::string& AudioMediaType::_internal_layout() const {
  return _impl_.layout_.Get();
}
inline void AudioMediaType::_internal_set_layout(const std::string& value) {
  
  _impl_.layout_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioMediaType::_internal_mutable_layout() {
  
  return _impl_.layout_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioMediaType::release_layout() {
  // @@protoc_insertion_point(field_release:AudioMediaType.layout)
  return _impl_.layout_.Release();
}
inline void AudioMediaType::set_allocated_layout(std::string* layout) {
  if (layout != nullptr) {
    
  } else {
    
  }
  _impl_.layout_.SetAllocated(layout, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.layout_.IsDefault()) {
    _impl_.layout_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AudioMediaType.layout)
}

// -------------------------------------------------------------------

// Stream_Pair

// string key = 1;
inline void Stream_Pair::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& Stream_Pair::key() const {
  // @@protoc_insertion_point(field_get:Stream.Pair.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream_Pair::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Stream.Pair.key)
}
inline std::string* Stream_Pair::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:Stream.Pair.key)
  return _s;
}
inline const std::string& Stream_Pair::_internal_key() const {
  return _impl_.key_.Get();
}
inline void Stream_Pair::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* Stream_Pair::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* Stream_Pair::release_key() {
  // @@protoc_insertion_point(field_release:Stream.Pair.key)
  return _impl_.key_.Release();
}
inline void Stream_Pair::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Stream.Pair.key)
}

// string value = 2;
inline void Stream_Pair::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& Stream_Pair::value() const {
  // @@protoc_insertion_point(field_get:Stream.Pair.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream_Pair::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Stream.Pair.value)
}
inline std::string* Stream_Pair::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:Stream.Pair.value)
  return _s;
}
inline const std::string& Stream_Pair::_internal_value() const {
  return _impl_.value_.Get();
}
inline void Stream_Pair::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Stream_Pair::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* Stream_Pair::release_value() {
  // @@protoc_insertion_point(field_release:Stream.Pair.value)
  return _impl_.value_.Release();
}
inline void Stream_Pair::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Stream.Pair.value)
}

// -------------------------------------------------------------------

// Stream

// uint32 id = 1;
inline void Stream::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t Stream::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t Stream::id() const {
  // @@protoc_insertion_point(field_get:Stream.id)
  return _internal_id();
}
inline void Stream::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void Stream::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Stream.id)
}

// .Stream.Type type = 2;
inline void Stream::clear_type() {
  _impl_.type_ = 0;
}
inline ::Stream_Type Stream::_internal_type() const {
  return static_cast< ::Stream_Type >(_impl_.type_);
}
inline ::Stream_Type Stream::type() const {
  // @@protoc_insertion_point(field_get:Stream.type)
  return _internal_type();
}
inline void Stream::_internal_set_type(::Stream_Type value) {
  
  _impl_.type_ = value;
}
inline void Stream::set_type(::Stream_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Stream.type)
}

// string codec = 3;
inline void Stream::clear_codec() {
  _impl_.codec_.ClearToEmpty();
}
inline const std::string& Stream::codec() const {
  // @@protoc_insertion_point(field_get:Stream.codec)
  return _internal_codec();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream::set_codec(ArgT0&& arg0, ArgT... args) {
 
 _impl_.codec_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Stream.codec)
}
inline std::string* Stream::mutable_codec() {
  std::string* _s = _internal_mutable_codec();
  // @@protoc_insertion_point(field_mutable:Stream.codec)
  return _s;
}
inline const std::string& Stream::_internal_codec() const {
  return _impl_.codec_.Get();
}
inline void Stream::_internal_set_codec(const std::string& value) {
  
  _impl_.codec_.Set(value, GetArenaForAllocation());
}
inline std::string* Stream::_internal_mutable_codec() {
  
  return _impl_.codec_.Mutable(GetArenaForAllocation());
}
inline std::string* Stream::release_codec() {
  // @@protoc_insertion_point(field_release:Stream.codec)
  return _impl_.codec_.Release();
}
inline void Stream::set_allocated_codec(std::string* codec) {
  if (codec != nullptr) {
    
  } else {
    
  }
  _impl_.codec_.SetAllocated(codec, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.codec_.IsDefault()) {
    _impl_.codec_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Stream.codec)
}

// uint32 bitrate = 4;
inline void Stream::clear_bitrate() {
  _impl_.bitrate_ = 0u;
}
inline uint32_t Stream::_internal_bitrate() const {
  return _impl_.bitrate_;
}
inline uint32_t Stream::bitrate() const {
  // @@protoc_insertion_point(field_get:Stream.bitrate)
  return _internal_bitrate();
}
inline void Stream::_internal_set_bitrate(uint32_t value) {
  
  _impl_.bitrate_ = value;
}
inline void Stream::set_bitrate(uint32_t value) {
  _internal_set_bitrate(value);
  // @@protoc_insertion_point(field_set:Stream.bitrate)
}

// uint32 tb_num = 5;
inline void Stream::clear_tb_num() {
  _impl_.tb_num_ = 0u;
}
inline uint32_t Stream::_internal_tb_num() const {
  return _impl_.tb_num_;
}
inline uint32_t Stream::tb_num() const {
  // @@protoc_insertion_point(field_get:Stream.tb_num)
  return _internal_tb_num();
}
inline void Stream::_internal_set_tb_num(uint32_t value) {
  
  _impl_.tb_num_ = value;
}
inline void Stream::set_tb_num(uint32_t value) {
  _internal_set_tb_num(value);
  // @@protoc_insertion_point(field_set:Stream.tb_num)
}

// uint32 tb_den = 6;
inline void Stream::clear_tb_den() {
  _impl_.tb_den_ = 0u;
}
inline uint32_t Stream::_internal_tb_den() const {
  return _impl_.tb_den_;
}
inline uint32_t Stream::tb_den() const {
  // @@protoc_insertion_point(field_get:Stream.tb_den)
  return _internal_tb_den();
}
inline void Stream::_internal_set_tb_den(uint32_t value) {
  
  _impl_.tb_den_ = value;
}
inline void Stream::set_tb_den(uint32_t value) {
  _internal_set_tb_den(value);
  // @@protoc_insertion_point(field_set:Stream.tb_den)
}

// bytes extradata = 7;
inline void Stream::clear_extradata() {
  _impl_.extradata_.ClearToEmpty();
}
inline const std::string& Stream::extradata() const {
  // @@protoc_insertion_point(field_get:Stream.extradata)
  return _internal_extradata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream::set_extradata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.extradata_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Stream.extradata)
}
inline std::string* Stream::mutable_extradata() {
  std::string* _s = _internal_mutable_extradata();
  // @@protoc_insertion_point(field_mutable:Stream.extradata)
  return _s;
}
inline const std::string& Stream::_internal_extradata() const {
  return _impl_.extradata_.Get();
}
inline void Stream::_internal_set_extradata(const std::string& value) {
  
  _impl_.extradata_.Set(value, GetArenaForAllocation());
}
inline std::string* Stream::_internal_mutable_extradata() {
  
  return _impl_.extradata_.Mutable(GetArenaForAllocation());
}
inline std::string* Stream::release_extradata() {
  // @@protoc_insertion_point(field_release:Stream.extradata)
  return _impl_.extradata_.Release();
}
inline void Stream::set_allocated_extradata(std::string* extradata) {
  if (extradata != nullptr) {
    
  } else {
    
  }
  _impl_.extradata_.SetAllocated(extradata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extradata_.IsDefault()) {
    _impl_.extradata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Stream.extradata)
}

// .VideoMediaType videomt = 8;
inline bool Stream::_internal_has_videomt() const {
  return this != internal_default_instance() && _impl_.videomt_ != nullptr;
}
inline bool Stream::has_videomt() const {
  return _internal_has_videomt();
}
inline void Stream::clear_videomt() {
  if (GetArenaForAllocation() == nullptr && _impl_.videomt_ != nullptr) {
    delete _impl_.videomt_;
  }
  _impl_.videomt_ = nullptr;
}
inline const ::VideoMediaType& Stream::_internal_videomt() const {
  const ::VideoMediaType* p = _impl_.videomt_;
  return p != nullptr ? *p : reinterpret_cast<const ::VideoMediaType&>(
      ::_VideoMediaType_default_instance_);
}
inline const ::VideoMediaType& Stream::videomt() const {
  // @@protoc_insertion_point(field_get:Stream.videomt)
  return _internal_videomt();
}
inline void Stream::unsafe_arena_set_allocated_videomt(
    ::VideoMediaType* videomt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.videomt_);
  }
  _impl_.videomt_ = videomt;
  if (videomt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Stream.videomt)
}
inline ::VideoMediaType* Stream::release_videomt() {
  
  ::VideoMediaType* temp = _impl_.videomt_;
  _impl_.videomt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::VideoMediaType* Stream::unsafe_arena_release_videomt() {
  // @@protoc_insertion_point(field_release:Stream.videomt)
  
  ::VideoMediaType* temp = _impl_.videomt_;
  _impl_.videomt_ = nullptr;
  return temp;
}
inline ::VideoMediaType* Stream::_internal_mutable_videomt() {
  
  if (_impl_.videomt_ == nullptr) {
    auto* p = CreateMaybeMessage<::VideoMediaType>(GetArenaForAllocation());
    _impl_.videomt_ = p;
  }
  return _impl_.videomt_;
}
inline ::VideoMediaType* Stream::mutable_videomt() {
  ::VideoMediaType* _msg = _internal_mutable_videomt();
  // @@protoc_insertion_point(field_mutable:Stream.videomt)
  return _msg;
}
inline void Stream::set_allocated_videomt(::VideoMediaType* videomt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.videomt_;
  }
  if (videomt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(videomt);
    if (message_arena != submessage_arena) {
      videomt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, videomt, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.videomt_ = videomt;
  // @@protoc_insertion_point(field_set_allocated:Stream.videomt)
}

// .AudioMediaType audiomt = 9;
inline bool Stream::_internal_has_audiomt() const {
  return this != internal_default_instance() && _impl_.audiomt_ != nullptr;
}
inline bool Stream::has_audiomt() const {
  return _internal_has_audiomt();
}
inline void Stream::clear_audiomt() {
  if (GetArenaForAllocation() == nullptr && _impl_.audiomt_ != nullptr) {
    delete _impl_.audiomt_;
  }
  _impl_.audiomt_ = nullptr;
}
inline const ::AudioMediaType& Stream::_internal_audiomt() const {
  const ::AudioMediaType* p = _impl_.audiomt_;
  return p != nullptr ? *p : reinterpret_cast<const ::AudioMediaType&>(
      ::_AudioMediaType_default_instance_);
}
inline const ::AudioMediaType& Stream::audiomt() const {
  // @@protoc_insertion_point(field_get:Stream.audiomt)
  return _internal_audiomt();
}
inline void Stream::unsafe_arena_set_allocated_audiomt(
    ::AudioMediaType* audiomt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audiomt_);
  }
  _impl_.audiomt_ = audiomt;
  if (audiomt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Stream.audiomt)
}
inline ::AudioMediaType* Stream::release_audiomt() {
  
  ::AudioMediaType* temp = _impl_.audiomt_;
  _impl_.audiomt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AudioMediaType* Stream::unsafe_arena_release_audiomt() {
  // @@protoc_insertion_point(field_release:Stream.audiomt)
  
  ::AudioMediaType* temp = _impl_.audiomt_;
  _impl_.audiomt_ = nullptr;
  return temp;
}
inline ::AudioMediaType* Stream::_internal_mutable_audiomt() {
  
  if (_impl_.audiomt_ == nullptr) {
    auto* p = CreateMaybeMessage<::AudioMediaType>(GetArenaForAllocation());
    _impl_.audiomt_ = p;
  }
  return _impl_.audiomt_;
}
inline ::AudioMediaType* Stream::mutable_audiomt() {
  ::AudioMediaType* _msg = _internal_mutable_audiomt();
  // @@protoc_insertion_point(field_mutable:Stream.audiomt)
  return _msg;
}
inline void Stream::set_allocated_audiomt(::AudioMediaType* audiomt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audiomt_;
  }
  if (audiomt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audiomt);
    if (message_arena != submessage_arena) {
      audiomt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audiomt, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audiomt_ = audiomt;
  // @@protoc_insertion_point(field_set_allocated:Stream.audiomt)
}

// string name = 10;
inline void Stream::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Stream::name() const {
  // @@protoc_insertion_point(field_get:Stream.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Stream.name)
}
inline std::string* Stream::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Stream.name)
  return _s;
}
inline const std::string& Stream::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Stream::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Stream::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Stream::release_name() {
  // @@protoc_insertion_point(field_release:Stream.name)
  return _impl_.name_.Release();
}
inline void Stream::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Stream.name)
}

// string channel = 11;
inline void Stream::clear_channel() {
  _impl_.channel_.ClearToEmpty();
}
inline const std::string& Stream::channel() const {
  // @@protoc_insertion_point(field_get:Stream.channel)
  return _internal_channel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream::set_channel(ArgT0&& arg0, ArgT... args) {
 
 _impl_.channel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Stream.channel)
}
inline std::string* Stream::mutable_channel() {
  std::string* _s = _internal_mutable_channel();
  // @@protoc_insertion_point(field_mutable:Stream.channel)
  return _s;
}
inline const std::string& Stream::_internal_channel() const {
  return _impl_.channel_.Get();
}
inline void Stream::_internal_set_channel(const std::string& value) {
  
  _impl_.channel_.Set(value, GetArenaForAllocation());
}
inline std::string* Stream::_internal_mutable_channel() {
  
  return _impl_.channel_.Mutable(GetArenaForAllocation());
}
inline std::string* Stream::release_channel() {
  // @@protoc_insertion_point(field_release:Stream.channel)
  return _impl_.channel_.Release();
}
inline void Stream::set_allocated_channel(std::string* channel) {
  if (channel != nullptr) {
    
  } else {
    
  }
  _impl_.channel_.SetAllocated(channel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.channel_.IsDefault()) {
    _impl_.channel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Stream.channel)
}

// .SubtitleMediaType subtitlemt = 12;
inline bool Stream::_internal_has_subtitlemt() const {
  return this != internal_default_instance() && _impl_.subtitlemt_ != nullptr;
}
inline bool Stream::has_subtitlemt() const {
  return _internal_has_subtitlemt();
}
inline void Stream::clear_subtitlemt() {
  if (GetArenaForAllocation() == nullptr && _impl_.subtitlemt_ != nullptr) {
    delete _impl_.subtitlemt_;
  }
  _impl_.subtitlemt_ = nullptr;
}
inline const ::SubtitleMediaType& Stream::_internal_subtitlemt() const {
  const ::SubtitleMediaType* p = _impl_.subtitlemt_;
  return p != nullptr ? *p : reinterpret_cast<const ::SubtitleMediaType&>(
      ::_SubtitleMediaType_default_instance_);
}
inline const ::SubtitleMediaType& Stream::subtitlemt() const {
  // @@protoc_insertion_point(field_get:Stream.subtitlemt)
  return _internal_subtitlemt();
}
inline void Stream::unsafe_arena_set_allocated_subtitlemt(
    ::SubtitleMediaType* subtitlemt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subtitlemt_);
  }
  _impl_.subtitlemt_ = subtitlemt;
  if (subtitlemt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Stream.subtitlemt)
}
inline ::SubtitleMediaType* Stream::release_subtitlemt() {
  
  ::SubtitleMediaType* temp = _impl_.subtitlemt_;
  _impl_.subtitlemt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SubtitleMediaType* Stream::unsafe_arena_release_subtitlemt() {
  // @@protoc_insertion_point(field_release:Stream.subtitlemt)
  
  ::SubtitleMediaType* temp = _impl_.subtitlemt_;
  _impl_.subtitlemt_ = nullptr;
  return temp;
}
inline ::SubtitleMediaType* Stream::_internal_mutable_subtitlemt() {
  
  if (_impl_.subtitlemt_ == nullptr) {
    auto* p = CreateMaybeMessage<::SubtitleMediaType>(GetArenaForAllocation());
    _impl_.subtitlemt_ = p;
  }
  return _impl_.subtitlemt_;
}
inline ::SubtitleMediaType* Stream::mutable_subtitlemt() {
  ::SubtitleMediaType* _msg = _internal_mutable_subtitlemt();
  // @@protoc_insertion_point(field_mutable:Stream.subtitlemt)
  return _msg;
}
inline void Stream::set_allocated_subtitlemt(::SubtitleMediaType* subtitlemt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.subtitlemt_;
  }
  if (subtitlemt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subtitlemt);
    if (message_arena != submessage_arena) {
      subtitlemt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subtitlemt, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.subtitlemt_ = subtitlemt;
  // @@protoc_insertion_point(field_set_allocated:Stream.subtitlemt)
}

// .DataMediaType datamt = 13;
inline bool Stream::_internal_has_datamt() const {
  return this != internal_default_instance() && _impl_.datamt_ != nullptr;
}
inline bool Stream::has_datamt() const {
  return _internal_has_datamt();
}
inline void Stream::clear_datamt() {
  if (GetArenaForAllocation() == nullptr && _impl_.datamt_ != nullptr) {
    delete _impl_.datamt_;
  }
  _impl_.datamt_ = nullptr;
}
inline const ::DataMediaType& Stream::_internal_datamt() const {
  const ::DataMediaType* p = _impl_.datamt_;
  return p != nullptr ? *p : reinterpret_cast<const ::DataMediaType&>(
      ::_DataMediaType_default_instance_);
}
inline const ::DataMediaType& Stream::datamt() const {
  // @@protoc_insertion_point(field_get:Stream.datamt)
  return _internal_datamt();
}
inline void Stream::unsafe_arena_set_allocated_datamt(
    ::DataMediaType* datamt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.datamt_);
  }
  _impl_.datamt_ = datamt;
  if (datamt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Stream.datamt)
}
inline ::DataMediaType* Stream::release_datamt() {
  
  ::DataMediaType* temp = _impl_.datamt_;
  _impl_.datamt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DataMediaType* Stream::unsafe_arena_release_datamt() {
  // @@protoc_insertion_point(field_release:Stream.datamt)
  
  ::DataMediaType* temp = _impl_.datamt_;
  _impl_.datamt_ = nullptr;
  return temp;
}
inline ::DataMediaType* Stream::_internal_mutable_datamt() {
  
  if (_impl_.datamt_ == nullptr) {
    auto* p = CreateMaybeMessage<::DataMediaType>(GetArenaForAllocation());
    _impl_.datamt_ = p;
  }
  return _impl_.datamt_;
}
inline ::DataMediaType* Stream::mutable_datamt() {
  ::DataMediaType* _msg = _internal_mutable_datamt();
  // @@protoc_insertion_point(field_mutable:Stream.datamt)
  return _msg;
}
inline void Stream::set_allocated_datamt(::DataMediaType* datamt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.datamt_;
  }
  if (datamt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(datamt);
    if (message_arena != submessage_arena) {
      datamt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, datamt, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.datamt_ = datamt;
  // @@protoc_insertion_point(field_set_allocated:Stream.datamt)
}

// repeated .Stream.Pair metadata = 14;
inline int Stream::_internal_metadata_size() const {
  return _impl_.metadata_.size();
}
inline int Stream::metadata_size() const {
  return _internal_metadata_size();
}
inline void Stream::clear_metadata() {
  _impl_.metadata_.Clear();
}
inline ::Stream_Pair* Stream::mutable_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:Stream.metadata)
  return _impl_.metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Stream_Pair >*
Stream::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:Stream.metadata)
  return &_impl_.metadata_;
}
inline const ::Stream_Pair& Stream::_internal_metadata(int index) const {
  return _impl_.metadata_.Get(index);
}
inline const ::Stream_Pair& Stream::metadata(int index) const {
  // @@protoc_insertion_point(field_get:Stream.metadata)
  return _internal_metadata(index);
}
inline ::Stream_Pair* Stream::_internal_add_metadata() {
  return _impl_.metadata_.Add();
}
inline ::Stream_Pair* Stream::add_metadata() {
  ::Stream_Pair* _add = _internal_add_metadata();
  // @@protoc_insertion_point(field_add:Stream.metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Stream_Pair >&
Stream::metadata() const {
  // @@protoc_insertion_point(field_list:Stream.metadata)
  return _impl_.metadata_;
}

// .CodecParameters avparams = 15;
inline bool Stream::_internal_has_avparams() const {
  return this != internal_default_instance() && _impl_.avparams_ != nullptr;
}
inline bool Stream::has_avparams() const {
  return _internal_has_avparams();
}
inline void Stream::clear_avparams() {
  if (GetArenaForAllocation() == nullptr && _impl_.avparams_ != nullptr) {
    delete _impl_.avparams_;
  }
  _impl_.avparams_ = nullptr;
}
inline const ::CodecParameters& Stream::_internal_avparams() const {
  const ::CodecParameters* p = _impl_.avparams_;
  return p != nullptr ? *p : reinterpret_cast<const ::CodecParameters&>(
      ::_CodecParameters_default_instance_);
}
inline const ::CodecParameters& Stream::avparams() const {
  // @@protoc_insertion_point(field_get:Stream.avparams)
  return _internal_avparams();
}
inline void Stream::unsafe_arena_set_allocated_avparams(
    ::CodecParameters* avparams) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.avparams_);
  }
  _impl_.avparams_ = avparams;
  if (avparams) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Stream.avparams)
}
inline ::CodecParameters* Stream::release_avparams() {
  
  ::CodecParameters* temp = _impl_.avparams_;
  _impl_.avparams_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CodecParameters* Stream::unsafe_arena_release_avparams() {
  // @@protoc_insertion_point(field_release:Stream.avparams)
  
  ::CodecParameters* temp = _impl_.avparams_;
  _impl_.avparams_ = nullptr;
  return temp;
}
inline ::CodecParameters* Stream::_internal_mutable_avparams() {
  
  if (_impl_.avparams_ == nullptr) {
    auto* p = CreateMaybeMessage<::CodecParameters>(GetArenaForAllocation());
    _impl_.avparams_ = p;
  }
  return _impl_.avparams_;
}
inline ::CodecParameters* Stream::mutable_avparams() {
  ::CodecParameters* _msg = _internal_mutable_avparams();
  // @@protoc_insertion_point(field_mutable:Stream.avparams)
  return _msg;
}
inline void Stream::set_allocated_avparams(::CodecParameters* avparams) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.avparams_;
  }
  if (avparams) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(avparams);
    if (message_arena != submessage_arena) {
      avparams = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, avparams, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.avparams_ = avparams;
  // @@protoc_insertion_point(field_set_allocated:Stream.avparams)
}

// -------------------------------------------------------------------

// CodecParameters

// uint32 codec_type = 1;
inline void CodecParameters::clear_codec_type() {
  _impl_.codec_type_ = 0u;
}
inline uint32_t CodecParameters::_internal_codec_type() const {
  return _impl_.codec_type_;
}
inline uint32_t CodecParameters::codec_type() const {
  // @@protoc_insertion_point(field_get:CodecParameters.codec_type)
  return _internal_codec_type();
}
inline void CodecParameters::_internal_set_codec_type(uint32_t value) {
  
  _impl_.codec_type_ = value;
}
inline void CodecParameters::set_codec_type(uint32_t value) {
  _internal_set_codec_type(value);
  // @@protoc_insertion_point(field_set:CodecParameters.codec_type)
}

// uint32 codec_id = 2;
inline void CodecParameters::clear_codec_id() {
  _impl_.codec_id_ = 0u;
}
inline uint32_t CodecParameters::_internal_codec_id() const {
  return _impl_.codec_id_;
}
inline uint32_t CodecParameters::codec_id() const {
  // @@protoc_insertion_point(field_get:CodecParameters.codec_id)
  return _internal_codec_id();
}
inline void CodecParameters::_internal_set_codec_id(uint32_t value) {
  
  _impl_.codec_id_ = value;
}
inline void CodecParameters::set_codec_id(uint32_t value) {
  _internal_set_codec_id(value);
  // @@protoc_insertion_point(field_set:CodecParameters.codec_id)
}

// uint32 codec_tag = 3;
inline void CodecParameters::clear_codec_tag() {
  _impl_.codec_tag_ = 0u;
}
inline uint32_t CodecParameters::_internal_codec_tag() const {
  return _impl_.codec_tag_;
}
inline uint32_t CodecParameters::codec_tag() const {
  // @@protoc_insertion_point(field_get:CodecParameters.codec_tag)
  return _internal_codec_tag();
}
inline void CodecParameters::_internal_set_codec_tag(uint32_t value) {
  
  _impl_.codec_tag_ = value;
}
inline void CodecParameters::set_codec_tag(uint32_t value) {
  _internal_set_codec_tag(value);
  // @@protoc_insertion_point(field_set:CodecParameters.codec_tag)
}

// bytes extradata = 4;
inline void CodecParameters::clear_extradata() {
  _impl_.extradata_.ClearToEmpty();
}
inline const std::string& CodecParameters::extradata() const {
  // @@protoc_insertion_point(field_get:CodecParameters.extradata)
  return _internal_extradata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CodecParameters::set_extradata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.extradata_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CodecParameters.extradata)
}
inline std::string* CodecParameters::mutable_extradata() {
  std::string* _s = _internal_mutable_extradata();
  // @@protoc_insertion_point(field_mutable:CodecParameters.extradata)
  return _s;
}
inline const std::string& CodecParameters::_internal_extradata() const {
  return _impl_.extradata_.Get();
}
inline void CodecParameters::_internal_set_extradata(const std::string& value) {
  
  _impl_.extradata_.Set(value, GetArenaForAllocation());
}
inline std::string* CodecParameters::_internal_mutable_extradata() {
  
  return _impl_.extradata_.Mutable(GetArenaForAllocation());
}
inline std::string* CodecParameters::release_extradata() {
  // @@protoc_insertion_point(field_release:CodecParameters.extradata)
  return _impl_.extradata_.Release();
}
inline void CodecParameters::set_allocated_extradata(std::string* extradata) {
  if (extradata != nullptr) {
    
  } else {
    
  }
  _impl_.extradata_.SetAllocated(extradata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extradata_.IsDefault()) {
    _impl_.extradata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CodecParameters.extradata)
}

// uint32 format = 5;
inline void CodecParameters::clear_format() {
  _impl_.format_ = 0u;
}
inline uint32_t CodecParameters::_internal_format() const {
  return _impl_.format_;
}
inline uint32_t CodecParameters::format() const {
  // @@protoc_insertion_point(field_get:CodecParameters.format)
  return _internal_format();
}
inline void CodecParameters::_internal_set_format(uint32_t value) {
  
  _impl_.format_ = value;
}
inline void CodecParameters::set_format(uint32_t value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:CodecParameters.format)
}

// uint64 bit_rate = 6;
inline void CodecParameters::clear_bit_rate() {
  _impl_.bit_rate_ = uint64_t{0u};
}
inline uint64_t CodecParameters::_internal_bit_rate() const {
  return _impl_.bit_rate_;
}
inline uint64_t CodecParameters::bit_rate() const {
  // @@protoc_insertion_point(field_get:CodecParameters.bit_rate)
  return _internal_bit_rate();
}
inline void CodecParameters::_internal_set_bit_rate(uint64_t value) {
  
  _impl_.bit_rate_ = value;
}
inline void CodecParameters::set_bit_rate(uint64_t value) {
  _internal_set_bit_rate(value);
  // @@protoc_insertion_point(field_set:CodecParameters.bit_rate)
}

// uint32 bits_per_coded_sample = 7;
inline void CodecParameters::clear_bits_per_coded_sample() {
  _impl_.bits_per_coded_sample_ = 0u;
}
inline uint32_t CodecParameters::_internal_bits_per_coded_sample() const {
  return _impl_.bits_per_coded_sample_;
}
inline uint32_t CodecParameters::bits_per_coded_sample() const {
  // @@protoc_insertion_point(field_get:CodecParameters.bits_per_coded_sample)
  return _internal_bits_per_coded_sample();
}
inline void CodecParameters::_internal_set_bits_per_coded_sample(uint32_t value) {
  
  _impl_.bits_per_coded_sample_ = value;
}
inline void CodecParameters::set_bits_per_coded_sample(uint32_t value) {
  _internal_set_bits_per_coded_sample(value);
  // @@protoc_insertion_point(field_set:CodecParameters.bits_per_coded_sample)
}

// uint32 bits_per_raw_sample = 8;
inline void CodecParameters::clear_bits_per_raw_sample() {
  _impl_.bits_per_raw_sample_ = 0u;
}
inline uint32_t CodecParameters::_internal_bits_per_raw_sample() const {
  return _impl_.bits_per_raw_sample_;
}
inline uint32_t CodecParameters::bits_per_raw_sample() const {
  // @@protoc_insertion_point(field_get:CodecParameters.bits_per_raw_sample)
  return _internal_bits_per_raw_sample();
}
inline void CodecParameters::_internal_set_bits_per_raw_sample(uint32_t value) {
  
  _impl_.bits_per_raw_sample_ = value;
}
inline void CodecParameters::set_bits_per_raw_sample(uint32_t value) {
  _internal_set_bits_per_raw_sample(value);
  // @@protoc_insertion_point(field_set:CodecParameters.bits_per_raw_sample)
}

// uint32 profile = 9;
inline void CodecParameters::clear_profile() {
  _impl_.profile_ = 0u;
}
inline uint32_t CodecParameters::_internal_profile() const {
  return _impl_.profile_;
}
inline uint32_t CodecParameters::profile() const {
  // @@protoc_insertion_point(field_get:CodecParameters.profile)
  return _internal_profile();
}
inline void CodecParameters::_internal_set_profile(uint32_t value) {
  
  _impl_.profile_ = value;
}
inline void CodecParameters::set_profile(uint32_t value) {
  _internal_set_profile(value);
  // @@protoc_insertion_point(field_set:CodecParameters.profile)
}

// uint32 level = 10;
inline void CodecParameters::clear_level() {
  _impl_.level_ = 0u;
}
inline uint32_t CodecParameters::_internal_level() const {
  return _impl_.level_;
}
inline uint32_t CodecParameters::level() const {
  // @@protoc_insertion_point(field_get:CodecParameters.level)
  return _internal_level();
}
inline void CodecParameters::_internal_set_level(uint32_t value) {
  
  _impl_.level_ = value;
}
inline void CodecParameters::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:CodecParameters.level)
}

// uint32 width = 11;
inline void CodecParameters::clear_width() {
  _impl_.width_ = 0u;
}
inline uint32_t CodecParameters::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t CodecParameters::width() const {
  // @@protoc_insertion_point(field_get:CodecParameters.width)
  return _internal_width();
}
inline void CodecParameters::_internal_set_width(uint32_t value) {
  
  _impl_.width_ = value;
}
inline void CodecParameters::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:CodecParameters.width)
}

// uint32 height = 12;
inline void CodecParameters::clear_height() {
  _impl_.height_ = 0u;
}
inline uint32_t CodecParameters::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t CodecParameters::height() const {
  // @@protoc_insertion_point(field_get:CodecParameters.height)
  return _internal_height();
}
inline void CodecParameters::_internal_set_height(uint32_t value) {
  
  _impl_.height_ = value;
}
inline void CodecParameters::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:CodecParameters.height)
}

// int32 sample_aspect_ratio_num = 13;
inline void CodecParameters::clear_sample_aspect_ratio_num() {
  _impl_.sample_aspect_ratio_num_ = 0;
}
inline int32_t CodecParameters::_internal_sample_aspect_ratio_num() const {
  return _impl_.sample_aspect_ratio_num_;
}
inline int32_t CodecParameters::sample_aspect_ratio_num() const {
  // @@protoc_insertion_point(field_get:CodecParameters.sample_aspect_ratio_num)
  return _internal_sample_aspect_ratio_num();
}
inline void CodecParameters::_internal_set_sample_aspect_ratio_num(int32_t value) {
  
  _impl_.sample_aspect_ratio_num_ = value;
}
inline void CodecParameters::set_sample_aspect_ratio_num(int32_t value) {
  _internal_set_sample_aspect_ratio_num(value);
  // @@protoc_insertion_point(field_set:CodecParameters.sample_aspect_ratio_num)
}

// int32 sample_aspect_ratio_den = 14;
inline void CodecParameters::clear_sample_aspect_ratio_den() {
  _impl_.sample_aspect_ratio_den_ = 0;
}
inline int32_t CodecParameters::_internal_sample_aspect_ratio_den() const {
  return _impl_.sample_aspect_ratio_den_;
}
inline int32_t CodecParameters::sample_aspect_ratio_den() const {
  // @@protoc_insertion_point(field_get:CodecParameters.sample_aspect_ratio_den)
  return _internal_sample_aspect_ratio_den();
}
inline void CodecParameters::_internal_set_sample_aspect_ratio_den(int32_t value) {
  
  _impl_.sample_aspect_ratio_den_ = value;
}
inline void CodecParameters::set_sample_aspect_ratio_den(int32_t value) {
  _internal_set_sample_aspect_ratio_den(value);
  // @@protoc_insertion_point(field_set:CodecParameters.sample_aspect_ratio_den)
}

// uint32 field_order = 15;
inline void CodecParameters::clear_field_order() {
  _impl_.field_order_ = 0u;
}
inline uint32_t CodecParameters::_internal_field_order() const {
  return _impl_.field_order_;
}
inline uint32_t CodecParameters::field_order() const {
  // @@protoc_insertion_point(field_get:CodecParameters.field_order)
  return _internal_field_order();
}
inline void CodecParameters::_internal_set_field_order(uint32_t value) {
  
  _impl_.field_order_ = value;
}
inline void CodecParameters::set_field_order(uint32_t value) {
  _internal_set_field_order(value);
  // @@protoc_insertion_point(field_set:CodecParameters.field_order)
}

// uint32 color_range = 16;
inline void CodecParameters::clear_color_range() {
  _impl_.color_range_ = 0u;
}
inline uint32_t CodecParameters::_internal_color_range() const {
  return _impl_.color_range_;
}
inline uint32_t CodecParameters::color_range() const {
  // @@protoc_insertion_point(field_get:CodecParameters.color_range)
  return _internal_color_range();
}
inline void CodecParameters::_internal_set_color_range(uint32_t value) {
  
  _impl_.color_range_ = value;
}
inline void CodecParameters::set_color_range(uint32_t value) {
  _internal_set_color_range(value);
  // @@protoc_insertion_point(field_set:CodecParameters.color_range)
}

// uint32 color_primaries = 17;
inline void CodecParameters::clear_color_primaries() {
  _impl_.color_primaries_ = 0u;
}
inline uint32_t CodecParameters::_internal_color_primaries() const {
  return _impl_.color_primaries_;
}
inline uint32_t CodecParameters::color_primaries() const {
  // @@protoc_insertion_point(field_get:CodecParameters.color_primaries)
  return _internal_color_primaries();
}
inline void CodecParameters::_internal_set_color_primaries(uint32_t value) {
  
  _impl_.color_primaries_ = value;
}
inline void CodecParameters::set_color_primaries(uint32_t value) {
  _internal_set_color_primaries(value);
  // @@protoc_insertion_point(field_set:CodecParameters.color_primaries)
}

// uint32 color_trc = 18;
inline void CodecParameters::clear_color_trc() {
  _impl_.color_trc_ = 0u;
}
inline uint32_t CodecParameters::_internal_color_trc() const {
  return _impl_.color_trc_;
}
inline uint32_t CodecParameters::color_trc() const {
  // @@protoc_insertion_point(field_get:CodecParameters.color_trc)
  return _internal_color_trc();
}
inline void CodecParameters::_internal_set_color_trc(uint32_t value) {
  
  _impl_.color_trc_ = value;
}
inline void CodecParameters::set_color_trc(uint32_t value) {
  _internal_set_color_trc(value);
  // @@protoc_insertion_point(field_set:CodecParameters.color_trc)
}

// uint32 color_space = 19;
inline void CodecParameters::clear_color_space() {
  _impl_.color_space_ = 0u;
}
inline uint32_t CodecParameters::_internal_color_space() const {
  return _impl_.color_space_;
}
inline uint32_t CodecParameters::color_space() const {
  // @@protoc_insertion_point(field_get:CodecParameters.color_space)
  return _internal_color_space();
}
inline void CodecParameters::_internal_set_color_space(uint32_t value) {
  
  _impl_.color_space_ = value;
}
inline void CodecParameters::set_color_space(uint32_t value) {
  _internal_set_color_space(value);
  // @@protoc_insertion_point(field_set:CodecParameters.color_space)
}

// uint32 chroma_location = 20;
inline void CodecParameters::clear_chroma_location() {
  _impl_.chroma_location_ = 0u;
}
inline uint32_t CodecParameters::_internal_chroma_location() const {
  return _impl_.chroma_location_;
}
inline uint32_t CodecParameters::chroma_location() const {
  // @@protoc_insertion_point(field_get:CodecParameters.chroma_location)
  return _internal_chroma_location();
}
inline void CodecParameters::_internal_set_chroma_location(uint32_t value) {
  
  _impl_.chroma_location_ = value;
}
inline void CodecParameters::set_chroma_location(uint32_t value) {
  _internal_set_chroma_location(value);
  // @@protoc_insertion_point(field_set:CodecParameters.chroma_location)
}

// uint32 video_delay = 21;
inline void CodecParameters::clear_video_delay() {
  _impl_.video_delay_ = 0u;
}
inline uint32_t CodecParameters::_internal_video_delay() const {
  return _impl_.video_delay_;
}
inline uint32_t CodecParameters::video_delay() const {
  // @@protoc_insertion_point(field_get:CodecParameters.video_delay)
  return _internal_video_delay();
}
inline void CodecParameters::_internal_set_video_delay(uint32_t value) {
  
  _impl_.video_delay_ = value;
}
inline void CodecParameters::set_video_delay(uint32_t value) {
  _internal_set_video_delay(value);
  // @@protoc_insertion_point(field_set:CodecParameters.video_delay)
}

// uint64 channel_layout = 22;
inline void CodecParameters::clear_channel_layout() {
  _impl_.channel_layout_ = uint64_t{0u};
}
inline uint64_t CodecParameters::_internal_channel_layout() const {
  return _impl_.channel_layout_;
}
inline uint64_t CodecParameters::channel_layout() const {
  // @@protoc_insertion_point(field_get:CodecParameters.channel_layout)
  return _internal_channel_layout();
}
inline void CodecParameters::_internal_set_channel_layout(uint64_t value) {
  
  _impl_.channel_layout_ = value;
}
inline void CodecParameters::set_channel_layout(uint64_t value) {
  _internal_set_channel_layout(value);
  // @@protoc_insertion_point(field_set:CodecParameters.channel_layout)
}

// uint32 channels = 23;
inline void CodecParameters::clear_channels() {
  _impl_.channels_ = 0u;
}
inline uint32_t CodecParameters::_internal_channels() const {
  return _impl_.channels_;
}
inline uint32_t CodecParameters::channels() const {
  // @@protoc_insertion_point(field_get:CodecParameters.channels)
  return _internal_channels();
}
inline void CodecParameters::_internal_set_channels(uint32_t value) {
  
  _impl_.channels_ = value;
}
inline void CodecParameters::set_channels(uint32_t value) {
  _internal_set_channels(value);
  // @@protoc_insertion_point(field_set:CodecParameters.channels)
}

// uint32 sample_rate = 24;
inline void CodecParameters::clear_sample_rate() {
  _impl_.sample_rate_ = 0u;
}
inline uint32_t CodecParameters::_internal_sample_rate() const {
  return _impl_.sample_rate_;
}
inline uint32_t CodecParameters::sample_rate() const {
  // @@protoc_insertion_point(field_get:CodecParameters.sample_rate)
  return _internal_sample_rate();
}
inline void CodecParameters::_internal_set_sample_rate(uint32_t value) {
  
  _impl_.sample_rate_ = value;
}
inline void CodecParameters::set_sample_rate(uint32_t value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:CodecParameters.sample_rate)
}

// uint32 block_align = 25;
inline void CodecParameters::clear_block_align() {
  _impl_.block_align_ = 0u;
}
inline uint32_t CodecParameters::_internal_block_align() const {
  return _impl_.block_align_;
}
inline uint32_t CodecParameters::block_align() const {
  // @@protoc_insertion_point(field_get:CodecParameters.block_align)
  return _internal_block_align();
}
inline void CodecParameters::_internal_set_block_align(uint32_t value) {
  
  _impl_.block_align_ = value;
}
inline void CodecParameters::set_block_align(uint32_t value) {
  _internal_set_block_align(value);
  // @@protoc_insertion_point(field_set:CodecParameters.block_align)
}

// uint32 frame_size = 26;
inline void CodecParameters::clear_frame_size() {
  _impl_.frame_size_ = 0u;
}
inline uint32_t CodecParameters::_internal_frame_size() const {
  return _impl_.frame_size_;
}
inline uint32_t CodecParameters::frame_size() const {
  // @@protoc_insertion_point(field_get:CodecParameters.frame_size)
  return _internal_frame_size();
}
inline void CodecParameters::_internal_set_frame_size(uint32_t value) {
  
  _impl_.frame_size_ = value;
}
inline void CodecParameters::set_frame_size(uint32_t value) {
  _internal_set_frame_size(value);
  // @@protoc_insertion_point(field_set:CodecParameters.frame_size)
}

// uint32 initial_padding = 27;
inline void CodecParameters::clear_initial_padding() {
  _impl_.initial_padding_ = 0u;
}
inline uint32_t CodecParameters::_internal_initial_padding() const {
  return _impl_.initial_padding_;
}
inline uint32_t CodecParameters::initial_padding() const {
  // @@protoc_insertion_point(field_get:CodecParameters.initial_padding)
  return _internal_initial_padding();
}
inline void CodecParameters::_internal_set_initial_padding(uint32_t value) {
  
  _impl_.initial_padding_ = value;
}
inline void CodecParameters::set_initial_padding(uint32_t value) {
  _internal_set_initial_padding(value);
  // @@protoc_insertion_point(field_set:CodecParameters.initial_padding)
}

// uint32 trailing_padding = 28;
inline void CodecParameters::clear_trailing_padding() {
  _impl_.trailing_padding_ = 0u;
}
inline uint32_t CodecParameters::_internal_trailing_padding() const {
  return _impl_.trailing_padding_;
}
inline uint32_t CodecParameters::trailing_padding() const {
  // @@protoc_insertion_point(field_get:CodecParameters.trailing_padding)
  return _internal_trailing_padding();
}
inline void CodecParameters::_internal_set_trailing_padding(uint32_t value) {
  
  _impl_.trailing_padding_ = value;
}
inline void CodecParameters::set_trailing_padding(uint32_t value) {
  _internal_set_trailing_padding(value);
  // @@protoc_insertion_point(field_set:CodecParameters.trailing_padding)
}

// uint32 seek_preroll = 29;
inline void CodecParameters::clear_seek_preroll() {
  _impl_.seek_preroll_ = 0u;
}
inline uint32_t CodecParameters::_internal_seek_preroll() const {
  return _impl_.seek_preroll_;
}
inline uint32_t CodecParameters::seek_preroll() const {
  // @@protoc_insertion_point(field_get:CodecParameters.seek_preroll)
  return _internal_seek_preroll();
}
inline void CodecParameters::_internal_set_seek_preroll(uint32_t value) {
  
  _impl_.seek_preroll_ = value;
}
inline void CodecParameters::set_seek_preroll(uint32_t value) {
  _internal_set_seek_preroll(value);
  // @@protoc_insertion_point(field_set:CodecParameters.seek_preroll)
}

// -------------------------------------------------------------------

// MediaPacket

// uint32 stream_id = 1;
inline void MediaPacket::clear_stream_id() {
  _impl_.stream_id_ = 0u;
}
inline uint32_t MediaPacket::_internal_stream_id() const {
  return _impl_.stream_id_;
}
inline uint32_t MediaPacket::stream_id() const {
  // @@protoc_insertion_point(field_get:MediaPacket.stream_id)
  return _internal_stream_id();
}
inline void MediaPacket::_internal_set_stream_id(uint32_t value) {
  
  _impl_.stream_id_ = value;
}
inline void MediaPacket::set_stream_id(uint32_t value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:MediaPacket.stream_id)
}

// uint64 dts = 2;
inline void MediaPacket::clear_dts() {
  _impl_.dts_ = uint64_t{0u};
}
inline uint64_t MediaPacket::_internal_dts() const {
  return _impl_.dts_;
}
inline uint64_t MediaPacket::dts() const {
  // @@protoc_insertion_point(field_get:MediaPacket.dts)
  return _internal_dts();
}
inline void MediaPacket::_internal_set_dts(uint64_t value) {
  
  _impl_.dts_ = value;
}
inline void MediaPacket::set_dts(uint64_t value) {
  _internal_set_dts(value);
  // @@protoc_insertion_point(field_set:MediaPacket.dts)
}

// uint32 pts_offset = 3;
inline void MediaPacket::clear_pts_offset() {
  _impl_.pts_offset_ = 0u;
}
inline uint32_t MediaPacket::_internal_pts_offset() const {
  return _impl_.pts_offset_;
}
inline uint32_t MediaPacket::pts_offset() const {
  // @@protoc_insertion_point(field_get:MediaPacket.pts_offset)
  return _internal_pts_offset();
}
inline void MediaPacket::_internal_set_pts_offset(uint32_t value) {
  
  _impl_.pts_offset_ = value;
}
inline void MediaPacket::set_pts_offset(uint32_t value) {
  _internal_set_pts_offset(value);
  // @@protoc_insertion_point(field_set:MediaPacket.pts_offset)
}

// .FrameType frametype = 4;
inline void MediaPacket::clear_frametype() {
  _impl_.frametype_ = 0;
}
inline ::FrameType MediaPacket::_internal_frametype() const {
  return static_cast< ::FrameType >(_impl_.frametype_);
}
inline ::FrameType MediaPacket::frametype() const {
  // @@protoc_insertion_point(field_get:MediaPacket.frametype)
  return _internal_frametype();
}
inline void MediaPacket::_internal_set_frametype(::FrameType value) {
  
  _impl_.frametype_ = value;
}
inline void MediaPacket::set_frametype(::FrameType value) {
  _internal_set_frametype(value);
  // @@protoc_insertion_point(field_set:MediaPacket.frametype)
}

// bytes data = 5;
inline void MediaPacket::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& MediaPacket::data() const {
  // @@protoc_insertion_point(field_get:MediaPacket.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MediaPacket::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MediaPacket.data)
}
inline std::string* MediaPacket::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:MediaPacket.data)
  return _s;
}
inline const std::string& MediaPacket::_internal_data() const {
  return _impl_.data_.Get();
}
inline void MediaPacket::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* MediaPacket::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* MediaPacket::release_data() {
  // @@protoc_insertion_point(field_release:MediaPacket.data)
  return _impl_.data_.Release();
}
inline void MediaPacket::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MediaPacket.data)
}

// uint32 duration = 6;
inline void MediaPacket::clear_duration() {
  _impl_.duration_ = 0u;
}
inline uint32_t MediaPacket::_internal_duration() const {
  return _impl_.duration_;
}
inline uint32_t MediaPacket::duration() const {
  // @@protoc_insertion_point(field_get:MediaPacket.duration)
  return _internal_duration();
}
inline void MediaPacket::_internal_set_duration(uint32_t value) {
  
  _impl_.duration_ = value;
}
inline void MediaPacket::set_duration(uint32_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:MediaPacket.duration)
}

// -------------------------------------------------------------------

// Start

// uint64 start_ts = 1;
inline void Start::clear_start_ts() {
  _impl_.start_ts_ = uint64_t{0u};
}
inline uint64_t Start::_internal_start_ts() const {
  return _impl_.start_ts_;
}
inline uint64_t Start::start_ts() const {
  // @@protoc_insertion_point(field_get:Start.start_ts)
  return _internal_start_ts();
}
inline void Start::_internal_set_start_ts(uint64_t value) {
  
  _impl_.start_ts_ = value;
}
inline void Start::set_start_ts(uint64_t value) {
  _internal_set_start_ts(value);
  // @@protoc_insertion_point(field_set:Start.start_ts)
}

// uint32 tb_num = 2;
inline void Start::clear_tb_num() {
  _impl_.tb_num_ = 0u;
}
inline uint32_t Start::_internal_tb_num() const {
  return _impl_.tb_num_;
}
inline uint32_t Start::tb_num() const {
  // @@protoc_insertion_point(field_get:Start.tb_num)
  return _internal_tb_num();
}
inline void Start::_internal_set_tb_num(uint32_t value) {
  
  _impl_.tb_num_ = value;
}
inline void Start::set_tb_num(uint32_t value) {
  _internal_set_tb_num(value);
  // @@protoc_insertion_point(field_set:Start.tb_num)
}

// uint32 tb_den = 3;
inline void Start::clear_tb_den() {
  _impl_.tb_den_ = 0u;
}
inline uint32_t Start::_internal_tb_den() const {
  return _impl_.tb_den_;
}
inline uint32_t Start::tb_den() const {
  // @@protoc_insertion_point(field_get:Start.tb_den)
  return _internal_tb_den();
}
inline void Start::_internal_set_tb_den(uint32_t value) {
  
  _impl_.tb_den_ = value;
}
inline void Start::set_tb_den(uint32_t value) {
  _internal_set_tb_den(value);
  // @@protoc_insertion_point(field_set:Start.tb_den)
}

// string channel = 4;
inline void Start::clear_channel() {
  _impl_.channel_.ClearToEmpty();
}
inline const std::string& Start::channel() const {
  // @@protoc_insertion_point(field_get:Start.channel)
  return _internal_channel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Start::set_channel(ArgT0&& arg0, ArgT... args) {
 
 _impl_.channel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Start.channel)
}
inline std::string* Start::mutable_channel() {
  std::string* _s = _internal_mutable_channel();
  // @@protoc_insertion_point(field_mutable:Start.channel)
  return _s;
}
inline const std::string& Start::_internal_channel() const {
  return _impl_.channel_.Get();
}
inline void Start::_internal_set_channel(const std::string& value) {
  
  _impl_.channel_.Set(value, GetArenaForAllocation());
}
inline std::string* Start::_internal_mutable_channel() {
  
  return _impl_.channel_.Mutable(GetArenaForAllocation());
}
inline std::string* Start::release_channel() {
  // @@protoc_insertion_point(field_release:Start.channel)
  return _impl_.channel_.Release();
}
inline void Start::set_allocated_channel(std::string* channel) {
  if (channel != nullptr) {
    
  } else {
    
  }
  _impl_.channel_.SetAllocated(channel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.channel_.IsDefault()) {
    _impl_.channel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Start.channel)
}

// -------------------------------------------------------------------

// Stop

// -------------------------------------------------------------------

// GopSlice

// int64 ts_num = 1;
inline void GopSlice::clear_ts_num() {
  _impl_.ts_num_ = int64_t{0};
}
inline int64_t GopSlice::_internal_ts_num() const {
  return _impl_.ts_num_;
}
inline int64_t GopSlice::ts_num() const {
  // @@protoc_insertion_point(field_get:GopSlice.ts_num)
  return _internal_ts_num();
}
inline void GopSlice::_internal_set_ts_num(int64_t value) {
  
  _impl_.ts_num_ = value;
}
inline void GopSlice::set_ts_num(int64_t value) {
  _internal_set_ts_num(value);
  // @@protoc_insertion_point(field_set:GopSlice.ts_num)
}

// int64 ts_den = 2;
inline void GopSlice::clear_ts_den() {
  _impl_.ts_den_ = int64_t{0};
}
inline int64_t GopSlice::_internal_ts_den() const {
  return _impl_.ts_den_;
}
inline int64_t GopSlice::ts_den() const {
  // @@protoc_insertion_point(field_get:GopSlice.ts_den)
  return _internal_ts_den();
}
inline void GopSlice::_internal_set_ts_den(int64_t value) {
  
  _impl_.ts_den_ = value;
}
inline void GopSlice::set_ts_den(int64_t value) {
  _internal_set_ts_den(value);
  // @@protoc_insertion_point(field_set:GopSlice.ts_den)
}

// int64 duration_num = 3;
inline void GopSlice::clear_duration_num() {
  _impl_.duration_num_ = int64_t{0};
}
inline int64_t GopSlice::_internal_duration_num() const {
  return _impl_.duration_num_;
}
inline int64_t GopSlice::duration_num() const {
  // @@protoc_insertion_point(field_get:GopSlice.duration_num)
  return _internal_duration_num();
}
inline void GopSlice::_internal_set_duration_num(int64_t value) {
  
  _impl_.duration_num_ = value;
}
inline void GopSlice::set_duration_num(int64_t value) {
  _internal_set_duration_num(value);
  // @@protoc_insertion_point(field_set:GopSlice.duration_num)
}

// int64 duration_den = 4;
inline void GopSlice::clear_duration_den() {
  _impl_.duration_den_ = int64_t{0};
}
inline int64_t GopSlice::_internal_duration_den() const {
  return _impl_.duration_den_;
}
inline int64_t GopSlice::duration_den() const {
  // @@protoc_insertion_point(field_get:GopSlice.duration_den)
  return _internal_duration_den();
}
inline void GopSlice::_internal_set_duration_den(int64_t value) {
  
  _impl_.duration_den_ = value;
}
inline void GopSlice::set_duration_den(int64_t value) {
  _internal_set_duration_den(value);
  // @@protoc_insertion_point(field_set:GopSlice.duration_den)
}

// repeated .MediaPacket packets = 5;
inline int GopSlice::_internal_packets_size() const {
  return _impl_.packets_.size();
}
inline int GopSlice::packets_size() const {
  return _internal_packets_size();
}
inline void GopSlice::clear_packets() {
  _impl_.packets_.Clear();
}
inline ::MediaPacket* GopSlice::mutable_packets(int index) {
  // @@protoc_insertion_point(field_mutable:GopSlice.packets)
  return _impl_.packets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MediaPacket >*
GopSlice::mutable_packets() {
  // @@protoc_insertion_point(field_mutable_list:GopSlice.packets)
  return &_impl_.packets_;
}
inline const ::MediaPacket& GopSlice::_internal_packets(int index) const {
  return _impl_.packets_.Get(index);
}
inline const ::MediaPacket& GopSlice::packets(int index) const {
  // @@protoc_insertion_point(field_get:GopSlice.packets)
  return _internal_packets(index);
}
inline ::MediaPacket* GopSlice::_internal_add_packets() {
  return _impl_.packets_.Add();
}
inline ::MediaPacket* GopSlice::add_packets() {
  ::MediaPacket* _add = _internal_add_packets();
  // @@protoc_insertion_point(field_add:GopSlice.packets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MediaPacket >&
GopSlice::packets() const {
  // @@protoc_insertion_point(field_list:GopSlice.packets)
  return _impl_.packets_;
}

// -------------------------------------------------------------------

// Msg

// .Msg.Type type = 1;
inline void Msg::clear_type() {
  _impl_.type_ = 0;
}
inline ::Msg_Type Msg::_internal_type() const {
  return static_cast< ::Msg_Type >(_impl_.type_);
}
inline ::Msg_Type Msg::type() const {
  // @@protoc_insertion_point(field_get:Msg.type)
  return _internal_type();
}
inline void Msg::_internal_set_type(::Msg_Type value) {
  
  _impl_.type_ = value;
}
inline void Msg::set_type(::Msg_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Msg.type)
}

// .Stop stop = 2;
inline bool Msg::_internal_has_stop() const {
  return this != internal_default_instance() && _impl_.stop_ != nullptr;
}
inline bool Msg::has_stop() const {
  return _internal_has_stop();
}
inline void Msg::clear_stop() {
  if (GetArenaForAllocation() == nullptr && _impl_.stop_ != nullptr) {
    delete _impl_.stop_;
  }
  _impl_.stop_ = nullptr;
}
inline const ::Stop& Msg::_internal_stop() const {
  const ::Stop* p = _impl_.stop_;
  return p != nullptr ? *p : reinterpret_cast<const ::Stop&>(
      ::_Stop_default_instance_);
}
inline const ::Stop& Msg::stop() const {
  // @@protoc_insertion_point(field_get:Msg.stop)
  return _internal_stop();
}
inline void Msg::unsafe_arena_set_allocated_stop(
    ::Stop* stop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stop_);
  }
  _impl_.stop_ = stop;
  if (stop) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Msg.stop)
}
inline ::Stop* Msg::release_stop() {
  
  ::Stop* temp = _impl_.stop_;
  _impl_.stop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Stop* Msg::unsafe_arena_release_stop() {
  // @@protoc_insertion_point(field_release:Msg.stop)
  
  ::Stop* temp = _impl_.stop_;
  _impl_.stop_ = nullptr;
  return temp;
}
inline ::Stop* Msg::_internal_mutable_stop() {
  
  if (_impl_.stop_ == nullptr) {
    auto* p = CreateMaybeMessage<::Stop>(GetArenaForAllocation());
    _impl_.stop_ = p;
  }
  return _impl_.stop_;
}
inline ::Stop* Msg::mutable_stop() {
  ::Stop* _msg = _internal_mutable_stop();
  // @@protoc_insertion_point(field_mutable:Msg.stop)
  return _msg;
}
inline void Msg::set_allocated_stop(::Stop* stop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stop_;
  }
  if (stop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stop);
    if (message_arena != submessage_arena) {
      stop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stop, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stop_ = stop;
  // @@protoc_insertion_point(field_set_allocated:Msg.stop)
}

// .Start start = 3;
inline bool Msg::_internal_has_start() const {
  return this != internal_default_instance() && _impl_.start_ != nullptr;
}
inline bool Msg::has_start() const {
  return _internal_has_start();
}
inline void Msg::clear_start() {
  if (GetArenaForAllocation() == nullptr && _impl_.start_ != nullptr) {
    delete _impl_.start_;
  }
  _impl_.start_ = nullptr;
}
inline const ::Start& Msg::_internal_start() const {
  const ::Start* p = _impl_.start_;
  return p != nullptr ? *p : reinterpret_cast<const ::Start&>(
      ::_Start_default_instance_);
}
inline const ::Start& Msg::start() const {
  // @@protoc_insertion_point(field_get:Msg.start)
  return _internal_start();
}
inline void Msg::unsafe_arena_set_allocated_start(
    ::Start* start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_);
  }
  _impl_.start_ = start;
  if (start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Msg.start)
}
inline ::Start* Msg::release_start() {
  
  ::Start* temp = _impl_.start_;
  _impl_.start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Start* Msg::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:Msg.start)
  
  ::Start* temp = _impl_.start_;
  _impl_.start_ = nullptr;
  return temp;
}
inline ::Start* Msg::_internal_mutable_start() {
  
  if (_impl_.start_ == nullptr) {
    auto* p = CreateMaybeMessage<::Start>(GetArenaForAllocation());
    _impl_.start_ = p;
  }
  return _impl_.start_;
}
inline ::Start* Msg::mutable_start() {
  ::Start* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:Msg.start)
  return _msg;
}
inline void Msg::set_allocated_start(::Start* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.start_;
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(start);
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_ = start;
  // @@protoc_insertion_point(field_set_allocated:Msg.start)
}

// .Stream stream = 4;
inline bool Msg::_internal_has_stream() const {
  return this != internal_default_instance() && _impl_.stream_ != nullptr;
}
inline bool Msg::has_stream() const {
  return _internal_has_stream();
}
inline void Msg::clear_stream() {
  if (GetArenaForAllocation() == nullptr && _impl_.stream_ != nullptr) {
    delete _impl_.stream_;
  }
  _impl_.stream_ = nullptr;
}
inline const ::Stream& Msg::_internal_stream() const {
  const ::Stream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::Stream&>(
      ::_Stream_default_instance_);
}
inline const ::Stream& Msg::stream() const {
  // @@protoc_insertion_point(field_get:Msg.stream)
  return _internal_stream();
}
inline void Msg::unsafe_arena_set_allocated_stream(
    ::Stream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Msg.stream)
}
inline ::Stream* Msg::release_stream() {
  
  ::Stream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Stream* Msg::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:Msg.stream)
  
  ::Stream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::Stream* Msg::_internal_mutable_stream() {
  
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::Stream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::Stream* Msg::mutable_stream() {
  ::Stream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:Msg.stream)
  return _msg;
}
inline void Msg::set_allocated_stream(::Stream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stream_;
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stream);
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:Msg.stream)
}

// .MediaPacket mediapacket = 5;
inline bool Msg::_internal_has_mediapacket() const {
  return this != internal_default_instance() && _impl_.mediapacket_ != nullptr;
}
inline bool Msg::has_mediapacket() const {
  return _internal_has_mediapacket();
}
inline void Msg::clear_mediapacket() {
  if (GetArenaForAllocation() == nullptr && _impl_.mediapacket_ != nullptr) {
    delete _impl_.mediapacket_;
  }
  _impl_.mediapacket_ = nullptr;
}
inline const ::MediaPacket& Msg::_internal_mediapacket() const {
  const ::MediaPacket* p = _impl_.mediapacket_;
  return p != nullptr ? *p : reinterpret_cast<const ::MediaPacket&>(
      ::_MediaPacket_default_instance_);
}
inline const ::MediaPacket& Msg::mediapacket() const {
  // @@protoc_insertion_point(field_get:Msg.mediapacket)
  return _internal_mediapacket();
}
inline void Msg::unsafe_arena_set_allocated_mediapacket(
    ::MediaPacket* mediapacket) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mediapacket_);
  }
  _impl_.mediapacket_ = mediapacket;
  if (mediapacket) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Msg.mediapacket)
}
inline ::MediaPacket* Msg::release_mediapacket() {
  
  ::MediaPacket* temp = _impl_.mediapacket_;
  _impl_.mediapacket_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MediaPacket* Msg::unsafe_arena_release_mediapacket() {
  // @@protoc_insertion_point(field_release:Msg.mediapacket)
  
  ::MediaPacket* temp = _impl_.mediapacket_;
  _impl_.mediapacket_ = nullptr;
  return temp;
}
inline ::MediaPacket* Msg::_internal_mutable_mediapacket() {
  
  if (_impl_.mediapacket_ == nullptr) {
    auto* p = CreateMaybeMessage<::MediaPacket>(GetArenaForAllocation());
    _impl_.mediapacket_ = p;
  }
  return _impl_.mediapacket_;
}
inline ::MediaPacket* Msg::mutable_mediapacket() {
  ::MediaPacket* _msg = _internal_mutable_mediapacket();
  // @@protoc_insertion_point(field_mutable:Msg.mediapacket)
  return _msg;
}
inline void Msg::set_allocated_mediapacket(::MediaPacket* mediapacket) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mediapacket_;
  }
  if (mediapacket) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mediapacket);
    if (message_arena != submessage_arena) {
      mediapacket = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mediapacket, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mediapacket_ = mediapacket;
  // @@protoc_insertion_point(field_set_allocated:Msg.mediapacket)
}

// .GopSlice gopslice = 6;
inline bool Msg::_internal_has_gopslice() const {
  return this != internal_default_instance() && _impl_.gopslice_ != nullptr;
}
inline bool Msg::has_gopslice() const {
  return _internal_has_gopslice();
}
inline void Msg::clear_gopslice() {
  if (GetArenaForAllocation() == nullptr && _impl_.gopslice_ != nullptr) {
    delete _impl_.gopslice_;
  }
  _impl_.gopslice_ = nullptr;
}
inline const ::GopSlice& Msg::_internal_gopslice() const {
  const ::GopSlice* p = _impl_.gopslice_;
  return p != nullptr ? *p : reinterpret_cast<const ::GopSlice&>(
      ::_GopSlice_default_instance_);
}
inline const ::GopSlice& Msg::gopslice() const {
  // @@protoc_insertion_point(field_get:Msg.gopslice)
  return _internal_gopslice();
}
inline void Msg::unsafe_arena_set_allocated_gopslice(
    ::GopSlice* gopslice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gopslice_);
  }
  _impl_.gopslice_ = gopslice;
  if (gopslice) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Msg.gopslice)
}
inline ::GopSlice* Msg::release_gopslice() {
  
  ::GopSlice* temp = _impl_.gopslice_;
  _impl_.gopslice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GopSlice* Msg::unsafe_arena_release_gopslice() {
  // @@protoc_insertion_point(field_release:Msg.gopslice)
  
  ::GopSlice* temp = _impl_.gopslice_;
  _impl_.gopslice_ = nullptr;
  return temp;
}
inline ::GopSlice* Msg::_internal_mutable_gopslice() {
  
  if (_impl_.gopslice_ == nullptr) {
    auto* p = CreateMaybeMessage<::GopSlice>(GetArenaForAllocation());
    _impl_.gopslice_ = p;
  }
  return _impl_.gopslice_;
}
inline ::GopSlice* Msg::mutable_gopslice() {
  ::GopSlice* _msg = _internal_mutable_gopslice();
  // @@protoc_insertion_point(field_mutable:Msg.gopslice)
  return _msg;
}
inline void Msg::set_allocated_gopslice(::GopSlice* gopslice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.gopslice_;
  }
  if (gopslice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gopslice);
    if (message_arena != submessage_arena) {
      gopslice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gopslice, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.gopslice_ = gopslice;
  // @@protoc_insertion_point(field_set_allocated:Msg.gopslice)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::AudioMediaType_SampleFmt> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AudioMediaType_SampleFmt>() {
  return ::AudioMediaType_SampleFmt_descriptor();
}
template <> struct is_proto_enum< ::Stream_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Stream_Type>() {
  return ::Stream_Type_descriptor();
}
template <> struct is_proto_enum< ::Msg_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Msg_Type>() {
  return ::Msg_Type_descriptor();
}
template <> struct is_proto_enum< ::PixFmt> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PixFmt>() {
  return ::PixFmt_descriptor();
}
template <> struct is_proto_enum< ::FrameType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FrameType>() {
  return ::FrameType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_messages1_2eproto
